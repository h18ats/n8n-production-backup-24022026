{
  "name": "DEV - Taxi Luke 1 - Post Call Luke with context",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "triggerAtHour": 5
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -832,
        -304
      ],
      "id": "69e52669-26cd-41fa-8f27-80adc486cf45",
      "name": "Schedule Trigger",
      "disabled": true
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.dateTime",
      "typeVersion": 2,
      "position": [
        -608,
        -400
      ],
      "id": "b5bed91f-7312-4669-958e-3f06b4ba2ef5",
      "name": "Today"
    },
    {
      "parameters": {
        "jsCode": "// Normalize bios from \u201cResearch Attendee (Agent)\u201d\n// Works even if each item only has { output: \"<bio text>\" }.\n// If you also connect Input 1 with \u201cSlim Inputs for Agent\u201d (items with {name,email,domain}),\n// this node will align by index and/or fuzzy name to fill missing emails.\n//\n// Output (one per person):\n//   { emailLower?, email?, name?, domain?, bio, nameKey? }\n//\n// You can merge later by `emailLower` (preferred) and fall back to `nameKey` if email is missing.\n\nfunction clean(s){ return typeof s === 'string' ? s.trim() : ''; }\nfunction lower(s){ return typeof s === 'string' ? s.toLowerCase() : ''; }\n\n// --- regex helpers ---\nvar EMAIL_RE = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/ig;\nvar HOST_RE  = /\\b((?:[a-z0-9-]+\\.)+[a-z]{2,})\\b/ig;\n\n// strip ``` fences and collapse whitespace a bit\nfunction normalizeText(t){\n  var txt = String(t == null ? '' : t);\n  if (txt.indexOf('```') > -1) {\n    txt = txt.replace(/```json/ig,'').replace(/```/g,'');\n  }\n  // trim line ends, collapse >2 newlines to 2\n  txt = txt.split('\\n').map(function(l){ return l.replace(/\\s+$/,''); }).join('\\n');\n  txt = txt.replace(/\\n{3,}/g, '\\n\\n');\n  return txt.trim();\n}\n\n// naive name guess: take leading fragment before \" is \" or first line\nfunction guessNameFromBio(txt){\n  var t = clean(txt);\n  if (!t) return '';\n  var firstLine = t.split('\\n')[0];\n  var beforeIs = firstLine.toString().split(/\\s+is\\s+/i)[0];\n  var cand = clean(beforeIs.length >= 3 ? beforeIs : firstLine);\n  // Keep it reasonable: 2\u20135 words, title-case-ish\n  var words = cand.split(/\\s+/).filter(Boolean);\n  if (words.length > 6) words = words.slice(0,6);\n  // If it's something like \"Founder and director\", that's not a name; reject if no capital letter start\n  var hasCap = /^[A-Z]/.test(words[0] || '');\n  return hasCap ? words.join(' ') : '';\n}\n\nfunction extractEmailFromText(txt){\n  var m = String(txt||'').match(EMAIL_RE);\n  return (m && m.length) ? m[0] : '';\n}\n\nfunction extractDomainFromText(txt){\n  // pick a plausible company domain; ignore common service hosts\n  var IGNORE = { 'www.google.com':1,'linkedin.com':1,'www.linkedin.com':1,'twitter.com':1,'x.com':1,'facebook.com':1,'instagram.com':1,'youtube.com':1,'outlook.office365.com':1,'microsoft.com':1,'github.com':1,'medium.com':1 };\n  var hosts = []; var h;\n  var text = String(txt||'');\n  while ((h = HOST_RE.exec(text)) !== null){\n    var host = h[1].toLowerCase();\n    if (!IGNORE[host]) hosts.push(host);\n  }\n  // Return the most frequent non-ignored host if any\n  if (hosts.length === 0) return '';\n  var freq = {}; var best = '', bestN = -1;\n  for (var i=0;i<hosts.length;i++){ var k=hosts[i]; freq[k]=(freq[k]||0)+1; if (freq[k]>bestN){ bestN=freq[k]; best=k; } }\n  return best;\n}\n\nfunction domainFromEmail(email){\n  var e = lower(clean(email)); var at = e.indexOf('@'); return at>-1 ? e.slice(at+1) : '';\n}\n\n// --- collect inputs ---\nvar outItems = ($input.all(0) || []).map(function(i){ return i.json; });\nvar hintItems = []; try { hintItems = ($input.all(1) || []).map(function(i){ return i.json; }); } catch(_){}\n\n// Build hint maps (by index, by lower(name), by lower(email))\nvar hintsByIndex = hintItems;\nvar hintsByName  = {};\nvar hintsByEmail = {};\nfor (var hi=0; hi<hintItems.length; hi++){\n  var h = hintItems[hi] || {};\n  var hEmail = clean(h.email || (h.emailAddress && h.emailAddress.address) || '');\n  var hName  = clean(h.name || h.person || h.fullName || h.attendeeName || '');\n  if (hName) hintsByName[lower(hName)] = h;\n  if (hEmail) hintsByEmail[lower(hEmail)] = h;\n}\n\n// Process each research output\nvar results = [];\n\nfor (var i=0; i<outItems.length; i++){\n  var row = outItems[i] || {};\n  var bioRaw = (row.bio !== undefined ? row.bio : (row.output !== undefined ? row.output : (row.text !== undefined ? row.text : row.content)));\n  var bio = normalizeText(bioRaw);\n\n  // Try to resolve identity\n  var email = extractEmailFromText(bio);\n  var name  = '';\n  var domain = '';\n\n  // If no email in text, try to align with hints\n  if (!email && hintsByIndex[i]){\n    var h = hintsByIndex[i];\n    var hEmail = clean(h.email || (h.emailAddress && h.emailAddress.address) || '');\n    if (hEmail) email = hEmail;\n    name = clean(h.name || h.person || h.fullName || h.attendeeName || '');\n    domain = clean(h.domain || '');\n  }\n\n  // If still no email, try name-match from text \u2192 hintsByName\n  if (!email){\n    var guessName = guessNameFromBio(bio);\n    if (guessName && hintsByName[lower(guessName)]){\n      var hh = hintsByName[lower(guessName)];\n      email = clean(hh.email || (hh.emailAddress && hh.emailAddress.address) || '');\n      if (!name) name = clean(hh.name || hh.person || hh.fullName || hh.attendeeName || guessName);\n      if (!domain) domain = clean(hh.domain || '');\n    } else if (guessName) {\n      name = name || guessName;\n    }\n  }\n\n  // Derive domain if still missing\n  if (!domain){\n    if (email) domain = domainFromEmail(email);\n    if (!domain){\n      var dTxt = extractDomainFromText(bio);\n      if (dTxt) domain = dTxt;\n    }\n  }\n\n  // Fallback name if still empty\n  if (!name) name = guessNameFromBio(bio);\n\n  var emailLower = lower(email);\n  var nameKey = lower(clean(name));\n\n  results.push({\n    emailLower: emailLower || '',\n    email: email || '',\n    name: name || '',\n    domain: domain || '',\n    nameKey: nameKey || '',\n    bio: bio\n  });\n}\n\n// Deduplicate by emailLower if available; else by nameKey\nvar bestByKey = {};\nfor (var r=0; r<results.length; r++){\n  var it = results[r];\n  var key = it.emailLower || ('name:' + it.nameKey);\n  if (!key) continue;\n  var prev = bestByKey[key];\n  if (!prev || it.bio.length > prev.bio.length){\n    bestByKey[key] = it;\n    // prefer real email if one version had none\n    if (prev && !prev.email && it.email) bestByKey[key].email = it.email;\n    if (prev && !prev.domain && it.domain) bestByKey[key].domain = it.domain;\n  } else {\n    // keep better name if longer\n    if (it.name && (!prev.name || it.name.length > prev.name.length)) bestByKey[key].name = it.name;\n    if (it.domain && !prev.domain) bestByKey[key].domain = it.domain;\n    if (it.email && !prev.email) bestByKey[key].email = it.email;\n  }\n}\n\n// Emit items\nvar out = [];\nfor (var k in bestByKey){\n  out.push({ json: bestByKey[k] });\n}\n\nif (out.length === 0){\n  // Emit diagnostics to help wire Input 1 properly\n  return [{\n    json: {\n      warning: \"No usable bios (no email/name could be resolved). Consider connecting Slim Inputs as Input 1.\",\n      sampleKeys: Object.keys(outItems[0] || {}),\n      note: \"If Agent output only has 'output' text, merge with Slim Inputs by index so we can attach emails.\"\n    }\n  }];\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        -928
      ],
      "id": "208f67cf-3ff9-457b-8c7c-2ba9e96f44ea",
      "name": "Normalize Bios"
    },
    {
      "parameters": {
        "jsCode": "// ---------- helpers ----------\nfunction clean(s){ return typeof s === 'string' ? s.trim() : ''; }\nfunction lower(s){ return typeof s === 'string' ? s.toLowerCase() : ''; }\nfunction get(o, path, d){\n  var parts = path.split('.'); var cur = o;\n  for (var i=0;i<parts.length;i++){ \n    var k=parts[i]; \n    if (cur && typeof cur==='object' && (k in cur)) cur = cur[k]; \n    else return d; \n  }\n  return cur;\n}\nfunction domainFromEmail(email){\n  var e = lower(clean(email)); \n  var at = e.indexOf('@'); \n  return at>-1 ? e.slice(at+1) : '';\n}\nfunction normalizeIso(s){\n  s = clean(s); if (!s) return null;\n  var t = s.replace(/Z$/,''); var dot = t.indexOf('.');\n  if (dot>-1) t = t.slice(0,dot);\n  if (t.length>=19) t = t.slice(0,19); // YYYY-MM-DDTHH:MM:SS\n  return t;\n}\nfunction isoFromEpochSec(sec){\n  if (typeof sec !== 'number') return null;\n  var d = new Date(sec*1000);\n  var yyyy = d.getUTCFullYear();\n  var mm = String(d.getUTCMonth()+1).padStart(2,'0');\n  var dd = String(d.getUTCDate()).padStart(2,'0');\n  var hh = String(d.getUTCHours()).padStart(2,'0');\n  var mi = String(d.getUTCMinutes()).padStart(2,'0');\n  var ss = String(d.getUTCSeconds()).padStart(2,'0');\n  return yyyy+'-'+mm+'-'+dd+'T'+hh+':'+mi+':'+ss;\n}\nfunction startISO(ev){\n  var s1 = get(ev,'start.dateTime', null); if (s1) return normalizeIso(String(s1));\n  var s2 = ev.startISO || get(ev,'start', null); if (typeof s2 === 'string') return normalizeIso(s2);\n  var e  = (typeof ev.epoch === 'number') ? ev.epoch : get(ev,'start.epoch', null);\n  if (typeof e === 'number') return normalizeIso(isoFromEpochSec(e));\n  return null;\n}\nfunction endISO(ev){\n  var e1 = get(ev,'end.dateTime', null); if (e1) return normalizeIso(String(e1));\n  var e2 = ev.endISO || get(ev,'end', null); if (typeof e2 === 'string') return normalizeIso(e2);\n  var ee = get(ev,'end.epoch', null);\n  if (typeof ee === 'number') return normalizeIso(isoFromEpochSec(ee));\n  return null;\n}\nfunction titleCase(s){\n  return s.split(/\\s+/).filter(Boolean).map(function(w){\n    return w.charAt(0).toUpperCase() + w.slice(1);\n  }).join(' ');\n}\nfunction inferCompanyFromDomain(domain){\n  domain = lower(clean(domain || ''));\n  if (!domain) return '';\n  var IGNORE = {\n    'gmail.com':1,'googlemail.com':1,'yahoo.com':1,'hotmail.com':1,'outlook.com':1,'live.com':1,\n    'msn.com':1,'icloud.com':1,'me.com':1,'proton.me':1,'protonmail.com':1,'gmx.com':1,'aol.com':1\n  };\n  if (IGNORE[domain]) return '';\n  var d = domain.replace(/^(mail|owa|webmail|mx|smtp|imap|app|portal|m|eu|us)\\./, '');\n  var multiTLDs = ['co.uk','com.au','com.br','com.ar','com.mx','co.jp','co.in','com.sg','com.hk','com.tr','com.cn','co.nz'];\n  for (var i=0;i<multiTLDs.length;i++){\n    var tld = multiTLDs[i];\n    if (d.endsWith('.' + tld)){\n      var base = d.slice(0, -(tld.length + 1));\n      var parts = base.split('.');\n      var label = parts[parts.length - 1] || base;\n      return titleCase(label.replace(/-/g,' '));\n    }\n  }\n  var parts2 = d.split('.');\n  if (parts2.length >= 2){\n    var core = parts2[parts2.length - 2];\n    return titleCase(core.replace(/-/g,' '));\n  }\n  return titleCase(d.replace(/-/g,' '));\n}\nfunction extractJobTitles(text){\n  var t = ' ' + clean(text) + ' ';\n  if (!t) return [];\n  var pats = [\n    /\\bChief\\s+[A-Za-z&\\- ]{2,30}\\b/gi,\n    /\\b(CFO|CEO|COO|CTO|CIO|CMO|CPO|CISO|GC)\\b/gi,\n    /\\b(SVP|EVP|VP|Assoc\\.?\\s?VP|Vice\\s+President)\\b/gi,\n    /\\bManaging\\s+Director\\b/gi,\n    /\\bDirector(?:\\s+of\\s+[A-Za-z&\\- ]{2,40})?\\b/gi,\n    /\\bHead\\s+of\\s+[A-Za-z&\\- ]{2,40}\\b/gi,\n    /\\bGlobal\\s+Head\\s+of\\s+[A-Za-z&\\- ]{2,40}\\b/gi,\n    /\\bPartner\\b/gi,\n    /\\b(Associate\\s+Director|Senior\\s+Manager|Manager)\\b/gi,\n    /\\b(Consultant|Principal)\\b/gi,\n    /\\b(General\\s+Counsel|Legal\\s+Counsel|Counsel|Attorney|Solicitor|Barrister)\\b/gi,\n    /\\b(Product|Engineering|Sales|Marketing|Operations|Finance|HR|People|Data|Design)\\s+(Manager|Director|Lead|Head)\\b/gi,\n    /\\b(Account\\s+Executive|Business\\s+Development|Recruiter)\\b/gi\n  ];\n  var found = [];\n  for (var i=0;i<pats.length;i++){\n    var re = pats[i], m;\n    while ((m = re.exec(t)) !== null){\n      var val = clean(m[0]);\n      if (val && found.indexOf(val) === -1) found.push(val);\n    }\n  }\n  return found;\n}\n\n// ---------- main ----------\nvar items = $input.all().map(function(i){ return i.json || {}; });\nvar out = [];\n\nfor (var i=0;i<items.length;i++){\n  var ev = items[i] || {};\n\n  var meetingId = ev.id || ev.eventId || null;\n  var subject = clean(ev.subject || ev.Subject || '(No subject)');\n  var bodyPreview = clean(ev.description || ev.bodyPreview || '');\n  var jobTitles = extractJobTitles(bodyPreview);\n\n  var sISO = startISO(ev);\n  var eISO = endISO(ev);\n  var tz = get(ev,'start.timeZone', get(ev,'time.timeZone', get(ev,'end.timeZone','UTC')));\n\n  var attendeesRaw = Array.isArray(ev.attendees) ? ev.attendees : [];\n  var attendees = [];\n  for (var a=0; a<attendeesRaw.length; a++){\n    var att = attendeesRaw[a] || {};\n    var email = clean(att.email || get(att,'emailAddress.address',''));\n    var name  = clean(att.name || get(att,'emailAddress.name','') || (email ? email.split('@')[0] : ''));\n    var domain = domainFromEmail(email);\n    var company = inferCompanyFromDomain(domain);\n    var type = clean(att.type || '');\n    var response = clean(att.response || get(att,'status.response','') || '');\n    var respondedAt = clean(att.respondedAt || get(att,'status.time','') || '');\n\n    if (!name && !email) continue;\n\n    attendees.push({\n      name: name,\n      email: email,\n      domain: domain,\n      company: company,\n      type: type,\n      response: response,\n      respondedAt: respondedAt\n    });\n  }\n\n  attendees.sort(function(a,b){\n    var n = (a.name||'').localeCompare(b.name||''); \n    return n!==0 ? n : (a.email||'').localeCompare(b.email||'');\n  });\n\n  out.push({\n    json: {\n      meetingId: meetingId,\n      meetingSubject: subject,\n      startISO: sISO,\n      endISO: eISO,\n      timeZone: tz,\n      bodyPreview: bodyPreview,\n      jobTitles: jobTitles,\n      attendees: attendees\n    }\n  });\n}\n\n// ---- SORT MEETINGS BY DATE ----\n// Ascending (earliest \u2192 latest)\nout.sort(function(a, b) {\n  var da = new Date(a.json.startISO || 0);\n  var db = new Date(b.json.startISO || 0);\n  return da - db;\n});\n\n// For most recent first, swap to: return db - da;\n\nreturn out.length ? out : [{ json: { warning: 'No meetings found in input' } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        64,
        -480
      ],
      "id": "f2ecc9de-d5ea-48aa-8bf5-5744390fcae0",
      "name": "Clean Calendar Data"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -832,
        -112
      ],
      "id": "fdc1a6c6-22ee-4133-8ac4-0663eb099e5a",
      "name": "When clicking \u2018Execute workflow\u2019"
    },
    {
      "parameters": {
        "operation": "subtractFromDate",
        "magnitude": "={{ $json.currentDate }}",
        "duration": 3,
        "options": {}
      },
      "type": "n8n-nodes-base.dateTime",
      "typeVersion": 2,
      "position": [
        -384,
        -400
      ],
      "id": "eb6ac2b1-756e-4a6c-88e0-66b727df44ac",
      "name": "Last 3 days"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Filters meetings to only those with external attendees,\n * adds inferred company domain(s) and company name(s) from those domains.\n */\n\n// >>> Set your internal domains here (lowercase). Add more if needed.\nconst internalDomains = ['legalengine.co.uk'];\n\n// --- helpers ---\nfunction getEmail(att) {\n  return (\n    (att && (\n      att.email ||\n      att.address ||\n      att.mail ||\n      att.userPrincipalName ||\n      (att.emailAddress && (att.emailAddress.address || att.emailAddress.email)) ||\n      ''\n    )) || ''\n  ).toLowerCase();\n}\n\nfunction getName(att) {\n  return (\n    (att && (\n      att.name ||\n      att.displayName ||\n      (att.emailAddress && att.emailAddress.name) ||\n      ''\n    )) || ''\n  ).toString();\n}\n\nfunction isExternal(att) {\n  const email = getEmail(att);\n  if (email && internalDomains.length) {\n    const domain = email.split('@')[1] ? email.split('@')[1].toLowerCase() : '';\n    if (domain) return !internalDomains.includes(domain);\n  }\n  const flag =\n    att?.isExternal === true ||\n    att?.external === true ||\n    /external/i.test(String(att?.type || '')) ||\n    /external/i.test(String(att?.role || ''));\n  return !!flag;\n}\n\nfunction pick(...vals) {\n  return vals.find(v => v !== undefined && v !== null && v !== '') ?? null;\n}\n\n// Infer a company name from a domain (very basic heuristic)\nfunction inferCompanyName(domain) {\n  if (!domain) return null;\n  // Strip common TLDs and SLDs\n  const parts = domain.split('.');\n  if (parts.length < 2) return domain;\n  // Remove last part (TLD)\n  parts.pop();\n  // If second-level TLD (e.g. co.uk), remove again\n  if (['co', 'com', 'org', 'net'].includes(parts[parts.length - 1])) {\n    parts.pop();\n  }\n  return parts[parts.length - 1] || domain;\n}\n\n// --- main ---\nconst out = [];\n\nfor (const { json: m } of items) {\n  const attendees = Array.isArray(m.attendees) ? m.attendees : [];\n  if (!attendees.length) continue;\n\n  const externals = attendees.filter(isExternal);\n  if (!externals.length) continue;\n\n  const allNames = attendees.map(getName).filter(Boolean);\n  const allEmails = attendees.map(getEmail).filter(Boolean);\n  const externalNames = externals.map(getName).filter(Boolean);\n  const externalEmails = externals.map(getEmail).filter(Boolean);\n\n  // Extract domains from external emails\n  const externalDomains = Array.from(\n    new Set(\n      externalEmails\n        .map(e => e.split('@')[1] || null)\n        .filter(Boolean)\n    )\n  );\n\n  // Infer company names\n  const inferredCompanyNames = externalDomains\n    .map(inferCompanyName)\n    .filter(Boolean);\n\n  out.push({\n    json: {\n      id: pick(m.meetingId, m.id),\n      subject: pick(m.meetingSubject, m.subject, m.title),\n      start: pick(m.startISO, m.start, m.startTime),\n      end: pick(m.endISO, m.end, m.endTime),\n      timeZone: pick(m.timeZone, m.timezone),\n      attendeesCount: attendees.length,\n      hasExternalAttendees: true,\n\n      // Attendees (all)\n      attendeeNames: allNames,\n      attendeeEmails: allEmails,\n\n      // External attendees\n      externalAttendeeNames: externalNames,\n      externalAttendeeEmails: externalEmails,\n\n      // Inferred company info\n      inferredCompanyDomains: externalDomains,\n      inferredCompanyNames: inferredCompanyNames,\n\n      // Optional pass-through\n      organizer: m.organizer ?? null,\n      location: m.location ?? null,\n      bodyPreview: m.bodyPreview ?? null,\n      link: m.link ?? m.meetingLink ?? null,\n    }\n  });\n}\n\nreturn out;\n"
      },
      "id": "bca17878-2c87-4fdc-8b99-57f8e2ebc621",
      "name": "Extract Meetings with External Attendees",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        512,
        -576
      ]
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: items[items.length - 1].json   // keeps only the last output\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        736,
        -576
      ],
      "id": "beb4d39b-97ba-43b0-b48d-1cd0783ef1e8",
      "name": "Last Meeting"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1888,
        -928
      ],
      "id": "91fadb1d-adaa-463c-bf90-4522cee9e217",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Input per item (from previous node):\n * {\n *   id, subject, start, end, timeZone,\n *   externalAttendeeEmails: [ ... ],\n *   inferredCompanyNames: [ ... ],          // from previous node\n *   inferredCompanyDomains: [ ... ]         // optional, from previous node\n * }\n *\n * Output per meeting:\n * - individualExternalCompanyNames: [ \"acme\", \"acme\", \"globex\", ... ]\n * - externalCompanyNames: [ \"acme\", \"globex\" ]  // unique + filtered\n * - externalCompaniesAll: \"acme, globex\"\n */\n\n// --- helpers ---\nfunction normalizeCompanyName(name) {\n  return String(name || '')\n    .trim()\n    .toLowerCase()\n    .replace(/[\\s\\-\\._]/g, ''); // remove spaces, dashes, underscores, dots\n}\n\nfunction isFilteredCompany(name) {\n  const norm = normalizeCompanyName(name);\n  return norm === 'legalengine'; // matches \"legal engine\", \"legal-engine\", \"legal_engine\", etc.\n}\n\n// infer company name from a domain (basic heuristic)\nfunction inferCompanyNameFromDomain(domain) {\n  if (!domain) return null;\n  const parts = String(domain).toLowerCase().split('.').filter(Boolean);\n\n  if (parts.length === 0) return null;\n  // drop TLD\n  parts.pop();\n\n  // drop SLD like \"co\", \"com\", \"org\", \"net\" if present at end\n  if (parts.length && ['co', 'com', 'org', 'net'].includes(parts[parts.length - 1])) {\n    parts.pop();\n  }\n\n  const candidate = parts[parts.length - 1] || null;\n  return candidate;\n}\n\nfunction unique(arr) {\n  return Array.from(new Set(arr));\n}\n\nfunction pick(...vals) {\n  return vals.find(v => v !== undefined && v !== null && v !== '') ?? null;\n}\n\n// --- main ---\nconst out = [];\n\nfor (const { json } of items) {\n  // Pull base fields through (customise as needed)\n  const base = {\n    id: pick(json.id, json.meetingId),\n    subject: pick(json.subject, json.meetingSubject),\n    start: pick(json.start, json.startISO, json.startTime),\n    end: pick(json.end, json.endISO, json.endTime),\n    timeZone: pick(json.timeZone, json.timezone),\n  };\n\n  // Source arrays (may or may not exist)\n  const inferredNamesFromPrev = Array.isArray(json.inferredCompanyNames) ? json.inferredCompanyNames : [];\n  const externalEmails = Array.isArray(json.externalAttendeeEmails) ? json.externalAttendeeEmails : [];\n\n  // Build individual names list (one per external attendee) using email domains when needed\n  const individualExternalCompanyNames = externalEmails.map(e => {\n    const domain = (String(e).split('@')[1] || '').toLowerCase();\n    const inferred = inferCompanyNameFromDomain(domain);\n    return inferred || null;\n  }).filter(Boolean);\n\n  // Merge with prior inferred names (if any) then filter + dedupe\n  const combinedNames = [\n    ...inferredNamesFromPrev.map(String),\n    ...individualExternalCompanyNames.map(String),\n  ]\n    .map(s => s.trim())\n    .filter(Boolean)\n    .filter(n => !isFilteredCompany(n));\n\n  const externalCompanyNames = unique(combinedNames);\n\n  out.push({\n    json: {\n      ...base,\n\n      // keep original lists if you want\n      externalAttendeeEmails: externalEmails,\n      inferredCompanyNamesOriginal: inferredNamesFromPrev,\n\n      // requested outputs\n      individualExternalCompanyNames,         // one per external attendee (may include duplicates)\n      externalCompanyNames,                   // unique & filtered\n      externalCompaniesAll: externalCompanyNames.join(', '), // convenience string\n\n      // pass-throughs if present\n      attendeesCount: json.attendeesCount ?? null,\n      hasExternalAttendees: json.hasExternalAttendees ?? true,\n      organizer: json.organizer ?? null,\n      location: json.location ?? null,\n      link: json.link ?? null,\n    }\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1248,
        -528
      ],
      "id": "8b029a47-88ec-4e1f-bd9e-75c25bfb4cef",
      "name": "Meeting with?"
    },
    {
      "parameters": {
        "jsCode": "// Input: one item per meeting with arrays like:\n// externalAttendeeNames, externalAttendeeEmails, inferredCompanyDomains, inferredCompanyNames, subject, ...\nconst it = $input.item.json;\n\nconst names  = Array.isArray(it.externalAttendeeNames)  ? it.externalAttendeeNames  : [];\nconst emails = Array.isArray(it.externalAttendeeEmails) ? it.externalAttendeeEmails : [];\nconst domains = Array.isArray(it.inferredCompanyDomains) ? it.inferredCompanyDomains : [];\nconst companies = Array.isArray(it.inferredCompanyNames) ? it.inferredCompanyNames : [];\n\nconst out = [];\n\nfor (let i = 0; i < Math.max(names.length, emails.length); i++) {\n  const name  = names[i]  ?? '';\n  const email = emails[i] ?? '';\n  // Pick the first inferred company/domain if you don\u2019t have a 1:1 mapping\n  const company = companies[i] ?? companies[0] ?? '';\n  const domain  = domains[i]  ?? domains[0]  ?? '';\n\n  out.push({\n    json: {\n      subject: it.subject ?? it.meetingSubject ?? '',\n      attendeeName: name,\n      attendeeEmail: email,\n      inferredCompanyName: company,\n      inferredCompanyDomain: domain,\n\n      // pass-throughs if useful\n      meetingId: it.id ?? it.meetingId ?? '',\n      start: it.start ?? it.startISO ?? '',\n      end: it.end ?? it.endISO ?? '',\n    }\n  });\n}\n\nreturn out.length ? out : [{ json: { warning: \"No external attendees to process\" } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        -928
      ],
      "id": "84a6ab96-1fb6-40de-a509-d95b6ba07d01",
      "name": "Split Into indiv Inputs"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-mini-2025-08-07",
          "mode": "list",
          "cachedResultName": "gpt-5-mini-2025-08-07"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1552,
        -400
      ],
      "id": "584bb084-f571-4626-b710-813cc6ceea96",
      "name": "OpenAI Chat Model7",
      "credentials": {
        "openAiApi": {
          "id": "LldOhLNBReShSMkE",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-mini-2025-08-07",
          "mode": "list",
          "cachedResultName": "gpt-5-mini-2025-08-07"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        2128,
        -128
      ],
      "id": "19915d60-8f47-4318-ab34-067fed16813b",
      "name": "OpenAI Chat Model8",
      "credentials": {
        "openAiApi": {
          "id": "LldOhLNBReShSMkE",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Normalize bios from \u201cResearch Attendee (Agent)\u201d\n// Works even if each item only has { output: \"<bio text>\" }.\n// If you also connect Input 1 with \u201cSlim Inputs for Agent\u201d (items with {name,email,domain}),\n// this node will align by index and/or fuzzy name to fill missing emails.\n//\n// Output (one per person):\n//   { emailLower?, email?, name?, domain?, bio, nameKey? }\n//\n// You can merge later by `emailLower` (preferred) and fall back to `nameKey` if email is missing.\n\nfunction clean(s){ return typeof s === 'string' ? s.trim() : ''; }\nfunction lower(s){ return typeof s === 'string' ? s.toLowerCase() : ''; }\n\n// --- regex helpers ---\nvar EMAIL_RE = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/ig;\nvar HOST_RE  = /\\b((?:[a-z0-9-]+\\.)+[a-z]{2,})\\b/ig;\n\n// strip ``` fences and collapse whitespace a bit\nfunction normalizeText(t){\n  var txt = String(t == null ? '' : t);\n  if (txt.indexOf('```') > -1) {\n    txt = txt.replace(/```json/ig,'').replace(/```/g,'');\n  }\n  // trim line ends, collapse >2 newlines to 2\n  txt = txt.split('\\n').map(function(l){ return l.replace(/\\s+$/,''); }).join('\\n');\n  txt = txt.replace(/\\n{3,}/g, '\\n\\n');\n  return txt.trim();\n}\n\n// naive name guess: take leading fragment before \" is \" or first line\nfunction guessNameFromBio(txt){\n  var t = clean(txt);\n  if (!t) return '';\n  var firstLine = t.split('\\n')[0];\n  var beforeIs = firstLine.toString().split(/\\s+is\\s+/i)[0];\n  var cand = clean(beforeIs.length >= 3 ? beforeIs : firstLine);\n  // Keep it reasonable: 2\u20135 words, title-case-ish\n  var words = cand.split(/\\s+/).filter(Boolean);\n  if (words.length > 6) words = words.slice(0,6);\n  // If it's something like \"Founder and director\", that's not a name; reject if no capital letter start\n  var hasCap = /^[A-Z]/.test(words[0] || '');\n  return hasCap ? words.join(' ') : '';\n}\n\nfunction extractEmailFromText(txt){\n  var m = String(txt||'').match(EMAIL_RE);\n  return (m && m.length) ? m[0] : '';\n}\n\nfunction extractDomainFromText(txt){\n  // pick a plausible company domain; ignore common service hosts\n  var IGNORE = { 'www.google.com':1,'linkedin.com':1,'www.linkedin.com':1,'twitter.com':1,'x.com':1,'facebook.com':1,'instagram.com':1,'youtube.com':1,'outlook.office365.com':1,'microsoft.com':1,'github.com':1,'medium.com':1 };\n  var hosts = []; var h;\n  var text = String(txt||'');\n  while ((h = HOST_RE.exec(text)) !== null){\n    var host = h[1].toLowerCase();\n    if (!IGNORE[host]) hosts.push(host);\n  }\n  // Return the most frequent non-ignored host if any\n  if (hosts.length === 0) return '';\n  var freq = {}; var best = '', bestN = -1;\n  for (var i=0;i<hosts.length;i++){ var k=hosts[i]; freq[k]=(freq[k]||0)+1; if (freq[k]>bestN){ bestN=freq[k]; best=k; } }\n  return best;\n}\n\nfunction domainFromEmail(email){\n  var e = lower(clean(email)); var at = e.indexOf('@'); return at>-1 ? e.slice(at+1) : '';\n}\n\n// --- collect inputs ---\nvar outItems = ($input.all(0) || []).map(function(i){ return i.json; });\nvar hintItems = []; try { hintItems = ($input.all(1) || []).map(function(i){ return i.json; }); } catch(_){}\n\n// Build hint maps (by index, by lower(name), by lower(email))\nvar hintsByIndex = hintItems;\nvar hintsByName  = {};\nvar hintsByEmail = {};\nfor (var hi=0; hi<hintItems.length; hi++){\n  var h = hintItems[hi] || {};\n  var hEmail = clean(h.email || (h.emailAddress && h.emailAddress.address) || '');\n  var hName  = clean(h.name || h.person || h.fullName || h.attendeeName || '');\n  if (hName) hintsByName[lower(hName)] = h;\n  if (hEmail) hintsByEmail[lower(hEmail)] = h;\n}\n\n// Process each research output\nvar results = [];\n\nfor (var i=0; i<outItems.length; i++){\n  var row = outItems[i] || {};\n  var bioRaw = (row.bio !== undefined ? row.bio : (row.output !== undefined ? row.output : (row.text !== undefined ? row.text : row.content)));\n  var bio = normalizeText(bioRaw);\n\n  // Try to resolve identity\n  var email = extractEmailFromText(bio);\n  var name  = '';\n  var domain = '';\n\n  // If no email in text, try to align with hints\n  if (!email && hintsByIndex[i]){\n    var h = hintsByIndex[i];\n    var hEmail = clean(h.email || (h.emailAddress && h.emailAddress.address) || '');\n    if (hEmail) email = hEmail;\n    name = clean(h.name || h.person || h.fullName || h.attendeeName || '');\n    domain = clean(h.domain || '');\n  }\n\n  // If still no email, try name-match from text \u2192 hintsByName\n  if (!email){\n    var guessName = guessNameFromBio(bio);\n    if (guessName && hintsByName[lower(guessName)]){\n      var hh = hintsByName[lower(guessName)];\n      email = clean(hh.email || (hh.emailAddress && hh.emailAddress.address) || '');\n      if (!name) name = clean(hh.name || hh.person || hh.fullName || hh.attendeeName || guessName);\n      if (!domain) domain = clean(hh.domain || '');\n    } else if (guessName) {\n      name = name || guessName;\n    }\n  }\n\n  // Derive domain if still missing\n  if (!domain){\n    if (email) domain = domainFromEmail(email);\n    if (!domain){\n      var dTxt = extractDomainFromText(bio);\n      if (dTxt) domain = dTxt;\n    }\n  }\n\n  // Fallback name if still empty\n  if (!name) name = guessNameFromBio(bio);\n\n  var emailLower = lower(email);\n  var nameKey = lower(clean(name));\n\n  results.push({\n    emailLower: emailLower || '',\n    email: email || '',\n    name: name || '',\n    domain: domain || '',\n    nameKey: nameKey || '',\n    bio: bio\n  });\n}\n\n// Deduplicate by emailLower if available; else by nameKey\nvar bestByKey = {};\nfor (var r=0; r<results.length; r++){\n  var it = results[r];\n  var key = it.emailLower || ('name:' + it.nameKey);\n  if (!key) continue;\n  var prev = bestByKey[key];\n  if (!prev || it.bio.length > prev.bio.length){\n    bestByKey[key] = it;\n    // prefer real email if one version had none\n    if (prev && !prev.email && it.email) bestByKey[key].email = it.email;\n    if (prev && !prev.domain && it.domain) bestByKey[key].domain = it.domain;\n  } else {\n    // keep better name if longer\n    if (it.name && (!prev.name || it.name.length > prev.name.length)) bestByKey[key].name = it.name;\n    if (it.domain && !prev.domain) bestByKey[key].domain = it.domain;\n    if (it.email && !prev.email) bestByKey[key].email = it.email;\n  }\n}\n\n// Emit items\nvar out = [];\nfor (var k in bestByKey){\n  out.push({ json: bestByKey[k] });\n}\n\nif (out.length === 0){\n  // Emit diagnostics to help wire Input 1 properly\n  return [{\n    json: {\n      warning: \"No usable bios (no email/name could be resolved). Consider connecting Slim Inputs as Input 1.\",\n      sampleKeys: Object.keys(outItems[0] || {}),\n      note: \"If Agent output only has 'output' text, merge with Slim Inputs by index so we can attach emails.\"\n    }\n  }];\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1888,
        -624
      ],
      "id": "47aa5d58-7f17-4184-b629-20d56d4351e5",
      "name": "Normalize Summary"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2464,
        -352
      ],
      "id": "3edc2394-8730-40a7-88ea-53c9e9efda21",
      "name": "Aggregate2"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Input examples this handles:\n * 1) A stringified JSON like \"{\\\"data\\\":[{\\\"data\\\":[{\\\"bio\\\":\\\"Ray Meiring ...\\\"}]}]}\"\n * 2) An object like { data: [ { data: [ { bio: \"...\" }, ... ] } ] }\n * 3) A Perplexity-style { biz: \"{\\\"data\\\":[{\\\"output\\\":\\\"...\\\"}]}\" } or { biz: { data:[{output:\"...\"}] } }\n * 4) A long string that contains both escaped JSON and a readable tail (fallback: strip the JSON-looking prefix)\n *\n * Output:\n * { text: \"<single clean text stream>\" }\n */\n\nfunction safeParse(x) {\n  if (x == null) return null;\n  if (typeof x === 'object') return x;\n  if (typeof x === 'string') {\n    try { return JSON.parse(x); } catch { return null; }\n  }\n  return null;\n}\n\n// Collect all \"bio\" strings recursively\nfunction collectBios(obj, out) {\n  if (!obj) return;\n  if (typeof obj === 'string') return;\n  if (Array.isArray(obj)) { obj.forEach(v => collectBios(v, out)); return; }\n  if (typeof obj === 'object') {\n    if (typeof obj.bio === 'string' && obj.bio.trim()) out.push(obj.bio.trim());\n    for (const k of Object.keys(obj)) collectBios(obj[k], out);\n  }\n}\n\n// Try to extract Perplexity-like \"output\" fields\nfunction collectOutputs(obj, out) {\n  if (!obj) return;\n  if (typeof obj === 'string') return;\n  if (Array.isArray(obj)) { obj.forEach(v => collectOutputs(v, out)); return; }\n  if (typeof obj === 'object') {\n    if (typeof obj.output === 'string' && obj.output.trim()) out.push(obj.output.trim());\n    for (const k of Object.keys(obj)) collectOutputs(obj[k], out);\n  }\n}\n\n// Fallback: remove a leading escaped-JSON prefix and keep the human-readable tail\nfunction stripEscapedJsonPrefix(s) {\n  if (typeof s !== 'string') return '';\n  // Heuristic: if it starts with \"{\\\"\" or '{\"data\":', cut everything up to the first \" - \" and keep the rest\n  if (/^\\\\?{\\\\?\"/.test(s) || s.startsWith('{\"data\"')) {\n    const idx = s.indexOf(' - ');\n    if (idx !== -1) return s.slice(idx + 3).trim();\n  }\n  // Also unescape common \\\" artifacts\n  return s.replace(/\\\\\"/g, '\"').replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t').trim();\n}\n\n// ---- main ----\nconst input = $input.item.json;\n\n// 1) Find candidate sources\n// - direct text field\nlet textRaw = input.text || input.output || input.bio || null;\n\n// - people/text payload often under textPayload (from your merge packing), or directly at root\nconst peopleObj = input.textPayload || input.peoplePayload || input;\n\n// - biz payload (could be string or object)\nlet bizObj = input.bizPayload || input.biz || null;\nbizObj = safeParse(bizObj) || bizObj; // parse if string\n\n// 2) Try to assemble text from structured objects first\nconst bios = [];\ncollectBios(peopleObj, bios);\n\nconst bizOutputs = [];\ncollectOutputs(bizObj, bizOutputs);\n\n// 3) If we didn\u2019t get anything, try to parse the root if it\u2019s a stringified JSON\nif (!bios.length && typeof input === 'string') {\n  const parsed = safeParse(input);\n  if (parsed) collectBios(parsed, bios);\n}\n\n// 4) Build the final text\nlet blocks = [];\n\n// prefer bios (richest text you showed)\nif (bios.length) blocks.push(bios.join('\\n\\n'));\n\n// include biz output if present\nif (bizOutputs.length) blocks.push(bizOutputs.join('\\n\\n'));\n\n// if still nothing, fall back to stripping messy string content\nif (!blocks.length) {\n  // Pick the most likely raw string field to clean\n  const candidates = [\n    textRaw,\n    typeof input === 'string' ? input : null,\n    typeof input?.peoplePayload === 'string' ? input.peoplePayload : null,\n    typeof input?.biz === 'string' ? input.biz : null\n  ].filter(Boolean);\n\n  if (candidates.length) {\n    const cleaned = stripEscapedJsonPrefix(candidates[0]);\n    if (cleaned) blocks.push(cleaned);\n  }\n}\n\n// As a last resort, emit something explicit\nif (!blocks.length) blocks.push('No readable text content found.');\n\n// Output single text stream\nreturn [{\n  json: {\n    text: blocks.join('\\n\\n---\\n\\n')\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2688,
        -832
      ],
      "id": "38a88faf-e8c9-4f58-be79-dacd64e818ed",
      "name": "Biz & Attendee Compiler"
    },
    {
      "parameters": {
        "jsCode": "// Collect all \"output\" strings from all incoming items and return ONE item with a clean text stream.\n\nfunction safeParse(x) {\n  if (x == null) return null;\n  if (typeof x === 'object') return x;\n  if (typeof x === 'string') { try { return JSON.parse(x); } catch { return null; } }\n  return null;\n}\n\nfunction collectOutputs(obj, out) {\n  if (!obj) return;\n  if (typeof obj === 'string') {\n    const parsed = safeParse(obj);\n    if (parsed) { collectOutputs(parsed, out); return; }\n    // plain string fallback\n    const s = obj.trim();\n    if (s) out.push(s);\n    return;\n  }\n  if (Array.isArray(obj)) { obj.forEach(v => collectOutputs(v, out)); return; }\n\n  // object\n  if (typeof obj.output === 'string' && obj.output.trim()) out.push(obj.output.trim());\n  if (Array.isArray(obj.data)) obj.data.forEach(v => collectOutputs(v, out));\n\n  // scan other properties just in case\n  for (const k of Object.keys(obj)) {\n    if (k === 'data' || k === 'output') continue;\n    const v = obj[k];\n    if (typeof v === 'string' || Array.isArray(v) || (v && typeof v === 'object')) {\n      collectOutputs(v, out);\n    }\n  }\n}\n\nconst items = $input.all();\nconst outputs = [];\nfor (const it of items) {\n  collectOutputs(it.json, outputs);\n}\n\n// de-dup consecutive identical blocks; keep order\nconst merged = [];\nfor (const s of outputs) {\n  if (merged.length === 0 || merged[merged.length - 1] !== s) merged.push(s);\n}\n\n// Build single text stream\nconst text = merged.join('\\n\\n---\\n\\n') || 'No output text found.';\n\nreturn [{ json: { text } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2688,
        -352
      ],
      "id": "9aba07d3-bba0-4d25-9f00-033311f9d206",
      "name": "Biz Name compiler"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2912,
        -704
      ],
      "id": "f7469927-9942-473b-85e6-08ab07a6defb",
      "name": "Merge1"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2464,
        -832
      ],
      "id": "39ce56a7-8cfd-4f99-94b2-bc5b62a6ea6e",
      "name": "Aggregate1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.externalCompanyNames[0] }}",
        "options": {
          "systemMessage": "TASK:\nAct as an expert researcher, produce the most likely name for the company that would be their trading name if listed on their corporate website, using the Perplexity Search tool to perform the following task robustly. \n\nProduce the most likely name for the company that would be their trading name if listed on their corporate website\n\nOUTPUT:\nCompany name",
          "returnIntermediateSteps": false
        }
      },
      "id": "ac8efc98-bcda-4fc0-8f8f-388b195f4f1f",
      "name": "Research Biz Name",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        2112,
        -352
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2176,
        -832
      ],
      "id": "5bbac8f2-e0e8-4f71-8c64-efe71a0d6dde",
      "name": "Merge"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        3136,
        -704
      ],
      "id": "9b069368-fb23-4073-b293-dc9702cdbbd7",
      "name": "Aggregate3"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "803e81bc-4a66-48b7-b461-026276603f7c",
              "name": "data",
              "value": "={{ $json.data }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3808,
        -448
      ],
      "id": "24b0ac72-5f47-4d8e-9369-a8a0834b6c03",
      "name": "Set Nodes to pass"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "bQ5Smg7ZJKylNtbY",
          "mode": "list",
          "cachedResultName": "DEV - Taxi Luke 2 - Post Call Luke create Agent with KB"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        4032,
        -448
      ],
      "id": "85a744e7-6709-4497-913c-b43a96f43fdf",
      "name": "Execute Workflow"
    },
    {
      "parameters": {
        "resource": "event",
        "filters": {
          "custom": "=start/dateTime ge '{{ $json.newDate }}' and start/dateTime lt '{{ $('Today').item.json.currentDate }}'"
        }
      },
      "type": "n8n-nodes-base.microsoftOutlook",
      "typeVersion": 2,
      "position": [
        -160,
        -400
      ],
      "id": "efafa545-5fdc-4d61-8741-75cd2b123ed1",
      "name": "Grab events from Lara's diary",
      "webhookId": "6d512e0e-578d-47ce-8c51-b358688532f1",
      "credentials": {
        "microsoftOutlookOAuth2Api": {
          "id": "I89nsEwUWKSmmCbY",
          "name": "Microsoft Outlook Lara"
        }
      }
    },
    {
      "parameters": {
        "toRecipients": "lara@legalengine.co.uk",
        "subject": "No meeting found",
        "bodyContent": "Hi, unfortunatley I did not find any meetings in your diary for the time period I looked, try setting a different timescale.\n\nBest regards,\n\nLuke\nLegal Engine AI Agent",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.microsoftOutlook",
      "typeVersion": 2,
      "position": [
        512,
        -112
      ],
      "id": "0c337ced-f744-457d-be6a-c2a128aa9cb7",
      "name": "No meetings found",
      "webhookId": "045c26c4-31e8-451e-a2ec-7df9f095b541",
      "credentials": {
        "microsoftOutlookOAuth2Api": {
          "id": "I89nsEwUWKSmmCbY",
          "name": "Microsoft Outlook Lara"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "simmons-luke",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -832,
        -496
      ],
      "id": "9f52e6c9-86ca-41db-af77-e13e64827093",
      "name": "Post meeting Webhook",
      "webhookId": "c8c04f39-a62f-4c36-8094-4a1f141cd8fb"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.attendeeName }}\n{{ $json.inferredCompanyName }}",
        "options": {
          "systemMessage": "TASK\nYou are an expert research agent. You will be give the name and company for a meeting attendee, and you will use your Perplexity tool to research about them and and produce a meeting-ready executive bio. The main aim is to allow the user to build rapport and be able to reference their background and experience in the meeting such as current and past roles, prior companies, locations they've worked in the past and their current working location.\n\nSCOPE & PRIORITIES\n- Time horizon for \u201crecent\u201d: last 60 months (weight these details highest).\n- Full coverage window: last 10 years (include major roles/achievements).\n- Audience: internal meeting attendees who need quick, rapport-useful context.\n\nCONSTRAINTS\n- The `bio_400_words` field must be ~400 words (\u00b110%).\n- Use UK spelling and a professional, neutral tone.\n- Each role in `role_history` should include dates if available and a 1\u20132 sentence impact summary."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1184,
        -1024
      ],
      "id": "fb600442-99f2-46e7-a841-7978573df55a",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-mini",
          "mode": "list",
          "cachedResultName": "gpt-5-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1200,
        -800
      ],
      "id": "645a2284-e648-4413-81cc-ec21480f4cae",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "LldOhLNBReShSMkE",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": "sonar-pro",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "options": {
          "maxTokens": 2500,
          "temperature": 0.2
        },
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        1328,
        -800
      ],
      "id": "35ad83aa-ee9f-46b4-ae88-770b59ce2a7c",
      "name": "Perplexity",
      "credentials": {
        "perplexityApi": {
          "id": "pOqM7kFIqiYB3qGU",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.subject }}.\n{{ $json.externalCompanyNames[0] }}",
        "options": {
          "systemMessage": "=TASK\nYou are an expert research agent. You will be give the name of a company whom I am meeting with representatives from, and you will use your Perplexity tool to research about them and and produce a meeting-ready executive bio. The main aim is to allow the user to have a robust knowledge relating to the work the company does, it's background, what it's best known for and any particularly noteworthy acolades. Specifically look for anything that has been published in the last month.\n\n\nSCOPE & PRIORITIES\n- Time horizon for \u201crecent\u201d: last 60 months (weight these details highest).\n- Full coverage window: last 20 years (include major roles/achievements).\n- Audience: meeting attendees who need quick, rapport-useful context.\n\nCONSTRAINTS\n- Summary should be approx 500 words\n- Use UK spelling and a professional, neutral tone.\n",
          "returnIntermediateSteps": false
        }
      },
      "id": "690db5cd-c0b8-42aa-b91f-341eb9541d36",
      "name": "Research Biz",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        1536,
        -624
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Extract organiser details from a Microsoft Graph Calendar event (fast & robust).\n// Output: ONE item with organiser-prefixed fields.\n\nconst it = $input.item.json;\n\n// ---------- helpers ----------\nconst val = (s) => (typeof s === 'string' ? s.trim() : '');\nconst low = (s) => (typeof s === 'string' ? s.toLowerCase() : s);\nconst looksEmail = (s) => /@/.test(s);\n\nfunction splitName(fullName) {\n  const parts = (fullName || '').trim().split(/\\s+/).filter(Boolean);\n  if (!parts.length) return { firstName: '', lastName: '' };\n  if (parts.length === 1) return { firstName: parts[0], lastName: '' };\n  return { firstName: parts[0], lastName: parts.slice(1).join(' ') };\n}\n\nfunction inferOrgFromEmail(email) {\n  const m = (email || '').toLowerCase().match(/@([^@]+)$/);\n  if (!m) return '';\n  const firstLabel = m[1].split('.')[0]; // first DNS label\n  return firstLabel\n    .split('-')\n    .filter(Boolean)\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n}\n\n// Reads either a true array at obj[key] or flattened keys like key[0], key[1], ...\nfunction getIndexedArray(obj, baseKey) {\n  const direct = obj?.[baseKey];\n  if (Array.isArray(direct)) return direct.slice();\n\n  const arr = [];\n  for (const k of Object.keys(obj || {})) {\n    if (!k.startsWith(baseKey + '[')) continue;\n    const m = k.match(new RegExp(`^${baseKey}\\\\[(\\\\d+)\\\\]$`));\n    if (m) {\n      const idx = Number(m[1]);\n      if (!Number.isNaN(idx)) arr[idx] = obj[k];\n    }\n  }\n  return arr;\n}\n\nfunction pickFirst(arr) {\n  return Array.isArray(arr) && arr.length ? val(arr[0]) : '';\n}\n\n// ---------- pass-throughs (Graph fields first) ----------\nconst subject   = it.subject ?? it.meetingSubject ?? '';\nconst meetingId = it.id ?? it.meetingId ?? '';\nconst start     = (it.start && (it.start.dateTime || it.start)) ?? it.startISO ?? '';\nconst end       = (it.end && (it.end.dateTime || it.end)) ?? it.endISO ?? '';\nconst timeZone  = (it.start && it.start.timeZone) || it.timeZone || '';\n\n// ---------- primary: Graph organiser ----------\nlet organiserFullName = '';\nlet organiserEmail = '';\nlet organiserJobTitle = '';\nlet organiserOrganisation = '';\n\n// Graph-style organiser\nif (it.organizer && typeof it.organizer === 'object') {\n  const ea = it.organizer.emailAddress || it.organizer.email || it.organizer.mail || {};\n  if (typeof ea === 'object') {\n    organiserFullName = val(ea.name || ea.displayName || '');\n    organiserEmail    = low(val(ea.address || ea.emailAddress || ''));\n  } else if (typeof ea === 'string') {\n    if (ea.includes('@')) organiserEmail = low(val(ea));\n    else organiserFullName = val(ea);\n  }\n\n  organiserJobTitle = val(it.organizer.jobTitle || it.organizer.title || it.organizer.role || '');\n  organiserOrganisation = val(\n    it.organizer.organisation || it.organizer.organization || it.organizer.company || it.organizer.companyName || ''\n  );\n}\n\n// ---------- fallbacks from flat fields ----------\nif (!organiserFullName) {\n  organiserFullName =\n    val(it.organiserName) ||\n    val(it.organizerName) ||\n    val(it.organiserFullName) ||\n    val(it.organizerFullName) ||\n    val(it.hostName) ||\n    val(it.chairName) ||\n    '';\n}\nif (!organiserEmail) {\n  organiserEmail =\n    low(val(it.organiserEmail)) ||\n    low(val(it.organizerEmail)) ||\n    '';\n}\nif (!organiserJobTitle) {\n  organiserJobTitle =\n    val(it.organiserRole) ||\n    val(it.organizerRole) ||\n    val(it.organiserTitle) ||\n    val(it.organizerTitle) ||\n    val(it.hostTitle) ||\n    val(it.chairTitle) ||\n    '';\n}\nif (!organiserOrganisation) {\n  organiserOrganisation =\n    val(it.organiserOrganisation) ||\n    val(it.organizerOrganization) ||\n    val(it.organiserCompany) ||\n    val(it.organiserCompanyName) ||\n    pickFirst(it.inferredCompanyNames) ||\n    '';\n}\nif (!organiserOrganisation && organiserEmail) {\n  organiserOrganisation = inferOrgFromEmail(organiserEmail);\n}\n\n// ---------- secondary fallback: infer organiser from attendees (first internal) ----------\nif (!organiserEmail && !organiserFullName) {\n  // Use arrays if present (Graph also has attendees array of objects, but we\u2019ll align with your arrays for speed)\n  const attendeeEmails  = getIndexedArray(it, 'attendeeEmails').map(e => low(val(e))).filter(Boolean);\n  const attendeeNames   = getIndexedArray(it, 'attendeeNames').map(n => val(n));\n  const externalEmails  = getIndexedArray(it, 'externalAttendeeEmails').map(e => low(val(e))).filter(Boolean);\n  const externalSet = new Set(externalEmails);\n\n  // Pick the first attendee who is NOT external\n  for (let i = 0; i < Math.max(attendeeEmails.length, attendeeNames.length); i++) {\n    const em = attendeeEmails[i] || '';\n    if (!em || externalSet.has(em)) continue;\n\n    organiserEmail = em;\n\n    const nmRaw = attendeeNames[i] || '';\n    const nm = nmRaw && !looksEmail(nmRaw) ? nmRaw : '';\n    organiserFullName = nm;\n\n    if (!organiserOrganisation) organiserOrganisation = inferOrgFromEmail(organiserEmail);\n    break;\n  }\n\n  // If still nothing, try Graph attendees array of objects\n  if (!organiserEmail && Array.isArray(it.attendees)) {\n    for (const a of it.attendees) {\n      const ea = a?.emailAddress;\n      const addr = low(val(ea?.address));\n      if (!addr) continue;\n      // If externals are known, skip them\n      if (externalEmails.length && externalSet.has(addr)) continue;\n\n      organiserEmail = addr;\n      organiserFullName = organiserFullName || val(ea?.name || ea?.displayName || '');\n      organiserOrganisation = organiserOrganisation || inferOrgFromEmail(addr);\n      break;\n    }\n  }\n}\n\n// ---------- build names ----------\nconst { firstName: organiserFirstName, lastName: organiserLastName } = splitName(organiserFullName);\n\n// ---------- validate & return ----------\nif (!organiserEmail && !organiserFullName) {\n  return [{\n    json: {\n      warning: 'No organiser found after Graph/flat/attendees checks',\n      subject, meetingId, start, end, timeZone\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    organiserFullName,\n    organiserFirstName,\n    organiserLastName,\n    organiserJobTitle,\n    organiserEmail,\n    organiserOrganisation,\n    subject,\n    meetingId,\n    start,\n    end,\n    timeZone\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        48
      ],
      "id": "d95a3c64-4d1a-4a83-a7d3-9e4be4be9832",
      "name": "Organisers Details"
    },
    {
      "parameters": {
        "jsCode": "// Input: one item per meeting with arrays like:\n// attendeeNames, attendeeEmails, externalAttendeeEmails, subject, ...\n// Output: one item per INTERNAL attendee (excluding organiser & externals)\n\nconst it = $input.item.json;\n\nconst names  = Array.isArray(it.attendeeNames)  ? it.attendeeNames  : [];\nconst emails = Array.isArray(it.attendeeEmails) ? it.attendeeEmails : [];\n\nconst externalEmails = Array.isArray(it.externalAttendeeEmails)\n  ? it.externalAttendeeEmails.map(e => (typeof e === 'string' ? e.trim().toLowerCase() : ''))\n  : [];\n\nconst organiserEmail = (it.organiserEmail || it.organizerEmail || '').toLowerCase().trim();\n\nconst out = [];\n\nconst norm = s => (typeof s === 'string' ? s.trim() : '');\nconst looksEmail = s => /@/.test(s);\n\nfunction splitName(fullName) {\n  const parts = (fullName || '').trim().split(/\\s+/).filter(Boolean);\n  if (!parts.length) return { firstName: '', lastName: '' };\n  if (parts.length === 1) return { firstName: parts[0], lastName: '' };\n  return { firstName: parts[0], lastName: parts.slice(1).join(' ') };\n}\n\nfunction orgFromEmail(email) {\n  const m = (email || '').toLowerCase().match(/@([^@]+)$/);\n  if (!m) return '';\n  const domain = m[1]; // e.g. legalengine.co.uk or simmons-simmons.con\n  const firstLabel = domain.split('.')[0]; // legalengine / simmons-simmons\n  // Title-case hyphen-separated words: \"simmons-simmons\" -> \"Simmons Simmons\"\n  return firstLabel\n    .split('-')\n    .filter(Boolean)\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n}\n\nconst externalSet = new Set(externalEmails.filter(Boolean));\nconst seen = new Set(); // dedupe by email\n\nfor (let i = 0; i < Math.max(names.length, emails.length); i++) {\n  const emailRaw = emails[i] ?? '';\n  const email = emailRaw.toLowerCase().trim();\n  if (!email) continue;\n\n  // Exclude externals & organiser\n  if (externalSet.has(email)) continue;\n  if (organiserEmail && email === organiserEmail) continue;\n\n  // Dedupe\n  if (seen.has(email)) continue;\n  seen.add(email);\n\n  // Name handling: ignore if it looks like an email\n  const nameRaw = norm(names[i] ?? '');\n  const fullName = nameRaw && !looksEmail(nameRaw) ? nameRaw : '';\n  const { firstName, lastName } = splitName(fullName);\n\n  out.push({\n    json: {\n      subject: it.subject ?? it.meetingSubject ?? '',\n      fullName,\n      firstName,\n      lastName,\n      role: '', // no role available in this input\n      email,\n      organisation: orgFromEmail(email),\n\n      // pass-throughs if useful\n      meetingId: it.id ?? it.meetingId ?? '',\n      start: it.start ?? it.startISO ?? '',\n      end: it.end ?? it.endISO ?? '',\n    }\n  });\n}\n\nreturn out.length ? out : [{ json: { warning: \"No internal attendees to process\" } }];\n"
      },
      "id": "c47079e0-d2c4-4f07-8551-64bb852b4442",
      "name": "Internal meeting attendees",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        -160
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "f2141cf2-1196-4521-b206-00def7b641ff",
              "leftValue": "",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "88ba2b71-9d4b-4b1c-987a-e0ae959cf135",
      "name": "IF \u2014 No meetings Found",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        288,
        -480
      ]
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1248,
        -64
      ],
      "id": "bc4e5357-2e50-4491-9ec3-92ebb5b97fc1",
      "name": "Merge2"
    },
    {
      "parameters": {
        "model": "sonar-pro",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "options": {
          "maxTokens": 2500,
          "temperature": 0.2
        },
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        1680,
        -400
      ],
      "id": "24da9d80-dc1d-4ee2-8b5d-7c5d38018917",
      "name": "Perplexity2",
      "credentials": {
        "perplexityApi": {
          "id": "pOqM7kFIqiYB3qGU",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "model": "sonar-pro",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "options": {
          "maxTokens": 2500,
          "temperature": 0.3
        },
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        2256,
        -128
      ],
      "id": "e3846713-7f72-480a-b2fd-226d023f22b8",
      "name": "Perplexity1",
      "credentials": {
        "perplexityApi": {
          "id": "pOqM7kFIqiYB3qGU",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1600,
        -64
      ],
      "id": "2e9a5ba3-7bc3-4933-9efe-37ec00643c4b",
      "name": "Aggregate4"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        3584,
        -464
      ],
      "id": "02c917e4-530c-4359-8acf-607d2f1fa740",
      "name": "Aggregate5"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3360,
        -464
      ],
      "id": "ca9e20ca-69ab-4f3c-9ec5-2cf308977db8",
      "name": "Merge3"
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Today",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Today": {
      "main": [
        [
          {
            "node": "Last 3 days",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Bios": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Calendar Data": {
      "main": [
        [
          {
            "node": "IF \u2014 No meetings Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking \u2018Execute workflow\u2019": {
      "main": [
        [
          {
            "node": "Today",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Last 3 days": {
      "main": [
        [
          {
            "node": "Grab events from Lara's diary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Meetings with External Attendees": {
      "main": [
        [
          {
            "node": "Last Meeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Last Meeting": {
      "main": [
        [
          {
            "node": "Meeting with?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Split Into indiv Inputs",
            "type": "main",
            "index": 0
          },
          {
            "node": "Internal meeting attendees",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Meeting with?": {
      "main": [
        [
          {
            "node": "Research Biz Name",
            "type": "main",
            "index": 0
          },
          {
            "node": "Research Biz",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Into indiv Inputs": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model7": {
      "ai_languageModel": [
        [
          {
            "node": "Research Biz",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model8": {
      "ai_languageModel": [
        [
          {
            "node": "Research Biz Name",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Summary": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Aggregate2": {
      "main": [
        [
          {
            "node": "Biz Name compiler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Biz & Attendee Compiler": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Biz Name compiler": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Aggregate3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate1": {
      "main": [
        [
          {
            "node": "Biz & Attendee Compiler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Research Biz Name": {
      "main": [
        [
          {
            "node": "Aggregate2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Aggregate1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate3": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Nodes to pass": {
      "main": [
        [
          {
            "node": "Execute Workflow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Grab events from Lara's diary": {
      "main": [
        [
          {
            "node": "Clean Calendar Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Organisers Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Workflow": {
      "main": [
        []
      ]
    },
    "Post meeting Webhook": {
      "main": [
        [
          {
            "node": "Today",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Normalize Bios",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Perplexity": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Research Biz": {
      "main": [
        [
          {
            "node": "Normalize Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organisers Details": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Internal meeting attendees": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF \u2014 No meetings Found": {
      "main": [
        [
          {
            "node": "Extract Meetings with External Attendees",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No meetings found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Aggregate4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Perplexity2": {
      "ai_tool": [
        [
          {
            "node": "Research Biz",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Perplexity1": {
      "ai_tool": [
        [
          {
            "node": "Research Biz Name",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate4": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Aggregate5": {
      "main": [
        [
          {
            "node": "Set Nodes to pass",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "Aggregate5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "pinData": {},
  "triggerCount": 1,
  "meta": {
    "templateCredsSetupCompleted": true
  }
}