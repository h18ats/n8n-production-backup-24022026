{
  "name": "DEV - A1 Luke - Research Meeting Attendees - Andy",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Normalize bios from “Research Attendee (Agent)”\n// Works even if each item only has { output: \"<bio text>\" }.\n// If you also connect Input 1 with “Slim Inputs for Agent” (items with {name,email,domain}),\n// this node will align by index and/or fuzzy name to fill missing emails.\n//\n// Output (one per person):\n//   { emailLower?, email?, name?, domain?, bio, nameKey? }\n//\n// You can merge later by `emailLower` (preferred) and fall back to `nameKey` if email is missing.\n\nfunction clean(s){ return typeof s === 'string' ? s.trim() : ''; }\nfunction lower(s){ return typeof s === 'string' ? s.toLowerCase() : ''; }\n\n// --- regex helpers ---\nvar EMAIL_RE = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/ig;\nvar HOST_RE  = /\\b((?:[a-z0-9-]+\\.)+[a-z]{2,})\\b/ig;\n\n// strip ``` fences and collapse whitespace a bit\nfunction normalizeText(t){\n  var txt = String(t == null ? '' : t);\n  if (txt.indexOf('```') > -1) {\n    txt = txt.replace(/```json/ig,'').replace(/```/g,'');\n  }\n  // trim line ends, collapse >2 newlines to 2\n  txt = txt.split('\\n').map(function(l){ return l.replace(/\\s+$/,''); }).join('\\n');\n  txt = txt.replace(/\\n{3,}/g, '\\n\\n');\n  return txt.trim();\n}\n\n// naive name guess: take leading fragment before \" is \" or first line\nfunction guessNameFromBio(txt){\n  var t = clean(txt);\n  if (!t) return '';\n  var firstLine = t.split('\\n')[0];\n  var beforeIs = firstLine.toString().split(/\\s+is\\s+/i)[0];\n  var cand = clean(beforeIs.length >= 3 ? beforeIs : firstLine);\n  // Keep it reasonable: 2–5 words, title-case-ish\n  var words = cand.split(/\\s+/).filter(Boolean);\n  if (words.length > 6) words = words.slice(0,6);\n  // If it's something like \"Founder and director\", that's not a name; reject if no capital letter start\n  var hasCap = /^[A-Z]/.test(words[0] || '');\n  return hasCap ? words.join(' ') : '';\n}\n\nfunction extractEmailFromText(txt){\n  var m = String(txt||'').match(EMAIL_RE);\n  return (m && m.length) ? m[0] : '';\n}\n\nfunction extractDomainFromText(txt){\n  // pick a plausible company domain; ignore common service hosts\n  var IGNORE = { 'www.google.com':1,'linkedin.com':1,'www.linkedin.com':1,'twitter.com':1,'x.com':1,'facebook.com':1,'instagram.com':1,'youtube.com':1,'outlook.office365.com':1,'microsoft.com':1,'github.com':1,'medium.com':1 };\n  var hosts = []; var h;\n  var text = String(txt||'');\n  while ((h = HOST_RE.exec(text)) !== null){\n    var host = h[1].toLowerCase();\n    if (!IGNORE[host]) hosts.push(host);\n  }\n  // Return the most frequent non-ignored host if any\n  if (hosts.length === 0) return '';\n  var freq = {}; var best = '', bestN = -1;\n  for (var i=0;i<hosts.length;i++){ var k=hosts[i]; freq[k]=(freq[k]||0)+1; if (freq[k]>bestN){ bestN=freq[k]; best=k; } }\n  return best;\n}\n\nfunction domainFromEmail(email){\n  var e = lower(clean(email)); var at = e.indexOf('@'); return at>-1 ? e.slice(at+1) : '';\n}\n\n// --- collect inputs ---\nvar outItems = ($input.all(0) || []).map(function(i){ return i.json; });\nvar hintItems = []; try { hintItems = ($input.all(1) || []).map(function(i){ return i.json; }); } catch(_){}\n\n// Build hint maps (by index, by lower(name), by lower(email))\nvar hintsByIndex = hintItems;\nvar hintsByName  = {};\nvar hintsByEmail = {};\nfor (var hi=0; hi<hintItems.length; hi++){\n  var h = hintItems[hi] || {};\n  var hEmail = clean(h.email || (h.emailAddress && h.emailAddress.address) || '');\n  var hName  = clean(h.name || h.person || h.fullName || h.attendeeName || '');\n  if (hName) hintsByName[lower(hName)] = h;\n  if (hEmail) hintsByEmail[lower(hEmail)] = h;\n}\n\n// Process each research output\nvar results = [];\n\nfor (var i=0; i<outItems.length; i++){\n  var row = outItems[i] || {};\n  var bioRaw = (row.bio !== undefined ? row.bio : (row.output !== undefined ? row.output : (row.text !== undefined ? row.text : row.content)));\n  var bio = normalizeText(bioRaw);\n\n  // Try to resolve identity\n  var email = extractEmailFromText(bio);\n  var name  = '';\n  var domain = '';\n\n  // If no email in text, try to align with hints\n  if (!email && hintsByIndex[i]){\n    var h = hintsByIndex[i];\n    var hEmail = clean(h.email || (h.emailAddress && h.emailAddress.address) || '');\n    if (hEmail) email = hEmail;\n    name = clean(h.name || h.person || h.fullName || h.attendeeName || '');\n    domain = clean(h.domain || '');\n  }\n\n  // If still no email, try name-match from text → hintsByName\n  if (!email){\n    var guessName = guessNameFromBio(bio);\n    if (guessName && hintsByName[lower(guessName)]){\n      var hh = hintsByName[lower(guessName)];\n      email = clean(hh.email || (hh.emailAddress && hh.emailAddress.address) || '');\n      if (!name) name = clean(hh.name || hh.person || hh.fullName || hh.attendeeName || guessName);\n      if (!domain) domain = clean(hh.domain || '');\n    } else if (guessName) {\n      name = name || guessName;\n    }\n  }\n\n  // Derive domain if still missing\n  if (!domain){\n    if (email) domain = domainFromEmail(email);\n    if (!domain){\n      var dTxt = extractDomainFromText(bio);\n      if (dTxt) domain = dTxt;\n    }\n  }\n\n  // Fallback name if still empty\n  if (!name) name = guessNameFromBio(bio);\n\n  var emailLower = lower(email);\n  var nameKey = lower(clean(name));\n\n  results.push({\n    emailLower: emailLower || '',\n    email: email || '',\n    name: name || '',\n    domain: domain || '',\n    nameKey: nameKey || '',\n    bio: bio\n  });\n}\n\n// Deduplicate by emailLower if available; else by nameKey\nvar bestByKey = {};\nfor (var r=0; r<results.length; r++){\n  var it = results[r];\n  var key = it.emailLower || ('name:' + it.nameKey);\n  if (!key) continue;\n  var prev = bestByKey[key];\n  if (!prev || it.bio.length > prev.bio.length){\n    bestByKey[key] = it;\n    // prefer real email if one version had none\n    if (prev && !prev.email && it.email) bestByKey[key].email = it.email;\n    if (prev && !prev.domain && it.domain) bestByKey[key].domain = it.domain;\n  } else {\n    // keep better name if longer\n    if (it.name && (!prev.name || it.name.length > prev.name.length)) bestByKey[key].name = it.name;\n    if (it.domain && !prev.domain) bestByKey[key].domain = it.domain;\n    if (it.email && !prev.email) bestByKey[key].email = it.email;\n  }\n}\n\n// Emit items\nvar out = [];\nfor (var k in bestByKey){\n  out.push({ json: bestByKey[k] });\n}\n\nif (out.length === 0){\n  // Emit diagnostics to help wire Input 1 properly\n  return [{\n    json: {\n      warning: \"No usable bios (no email/name could be resolved). Consider connecting Slim Inputs as Input 1.\",\n      sampleKeys: Object.keys(outItems[0] || {}),\n      note: \"If Agent output only has 'output' text, merge with Slim Inputs by index so we can attach emails.\"\n    }\n  }];\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1248,
        -1056
      ],
      "id": "a643249f-e682-43a9-9d8b-cb5dc8c45c64",
      "name": "Normalize Bios"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -2304,
        -336
      ],
      "id": "885dbde2-e64a-49a5-a84e-185b80a70214",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Code node . Run Once for All Items\n * Reads events from \"Clean Calendar Data\"\n * Returns only events with external attendees\n */\n\nconst items = $items('Clean Calendar Data');\n\n// Your internal domains\nconst internalDomains = ['legalengine.co.uk'];\n\n// Pick helper\nfunction pick(...vals) {\n  return vals.find(v => v !== undefined && v !== null && v !== '') ?? null;\n}\n\n// Very basic company-name inference from domain\nfunction inferCompanyName(domain) {\n  if (!domain) return null;\n  const parts = domain.toLowerCase().split('.');\n  if (parts.length < 2) return domain;\n  // remove TLD\n  parts.pop();\n  // handle things like co.uk, com.au roughly\n  if (['co', 'com', 'org', 'net'].includes(parts[parts.length - 1])) {\n    parts.pop();\n  }\n  return parts[parts.length - 1] || domain;\n}\n\nconst out = [];\n\nfor (const item of items) {\n  const m = item.json ?? item;\n\n  const names = Array.isArray(m.attendeeNames) ? m.attendeeNames : [];\n  const emails = Array.isArray(m.attendeeEmails) ? m.attendeeEmails : [];\n\n  const externalNames = [];\n  const externalEmails = [];\n\n  // Walk attendee arrays by index so we can match name ↔ email\n  for (let i = 0; i < emails.length; i++) {\n    const emailRaw = emails[i];\n    if (!emailRaw) continue;\n\n    const email = String(emailRaw).trim().toLowerCase();\n    const domain = email.split('@')[1] || '';\n\n    if (!domain) continue;\n\n    const isInternal = internalDomains.includes(domain);\n    if (!isInternal) {\n      externalEmails.push(emailRaw);\n      externalNames.push(names[i] ?? null);\n    }\n  }\n\n  if (!externalEmails.length) {\n    // no external attendees . skip this event\n    continue;\n  }\n\n  // Unique external domains\n  const externalDomains = Array.from(\n    new Set(\n      externalEmails\n        .map(e => String(e).split('@')[1] || null)\n        .filter(Boolean)\n    )\n  );\n\n  const inferredCompanyNames = externalDomains\n    .map(inferCompanyName)\n    .filter(Boolean);\n\n  out.push({\n    json: {\n      // IDs and basic meta\n      id: pick(m.eventId, m.meetingId, m.id),\n      subject: pick(m.eventName, m.meetingSubject, m.subject, '(No subject)'),\n      start: pick(m.startDateTime, m.startISO, m.start),\n      end: pick(m.endDateTime, m.endISO, m.end),\n      timeZone: pick(m.startTimeZone, m.timeZone, m.timezone),\n      lengthMinutes: m.eventLengthMinutes ?? null,\n\n      // organiser\n      organiserName: m.eventOrganiserName ?? null,\n      organiserEmail: m.eventOrganiserEmail ?? null,\n\n      // counts and flags\n      attendeesCount: emails.length,\n      hasExternalAttendees: true,\n\n      // all attendees (from your cleaned arrays)\n      attendeeNames: names,\n      attendeeEmails: emails,\n\n      // external only\n      externalAttendeeNames: externalNames,\n      externalAttendeeEmails: externalEmails,\n\n      // inferred company info from externals\n      inferredCompanyDomains: externalDomains,\n      inferredCompanyNames: inferredCompanyNames,\n\n      // pass-through fields\n      location: m.location ?? null,\n      teamsJoinLink: m.teamsJoinLink ?? null,\n      teamsMeetingId: m.teamsMeetingId ?? null,\n      teamsPasscode: m.teamsPasscode ?? null,\n      webLink: m.webLink ?? null,\n    }\n  });\n}\n\nreturn out;"
      },
      "id": "35a9cb07-ea9e-4350-84c0-9859fa81e5c2",
      "name": "Extract Meetings with External Attendees",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        -608
      ]
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: items[items.length - 1].json   // keeps only the last output\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        384,
        -608
      ],
      "id": "eeb3b5c7-fcd5-4ce1-9682-09824c06b971",
      "name": "Last Meeting"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1536,
        -1056
      ],
      "id": "3803ea38-802f-41ef-8bd9-9b492dc0e592",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Input per item (from previous node):\n * {\n *   id, subject, start, end, timeZone,\n *   externalAttendeeEmails: [ ... ],\n *   inferredCompanyNames: [ ... ],          // from previous node\n *   inferredCompanyDomains: [ ... ]         // optional, from previous node\n * }\n *\n * Output per meeting:\n * - individualExternalCompanyNames: [ \"acme\", \"acme\", \"globex\", ... ]\n * - externalCompanyNames: [ \"acme\", \"globex\" ]  // unique + filtered\n * - externalCompaniesAll: \"acme, globex\"\n */\n\n// --- helpers ---\nfunction normalizeCompanyName(name) {\n  return String(name || '')\n    .trim()\n    .toLowerCase()\n    .replace(/[\\s\\-\\._]/g, ''); // remove spaces, dashes, underscores, dots\n}\n\nfunction isFilteredCompany(name) {\n  const norm = normalizeCompanyName(name);\n  return norm === 'legalengine'; // matches \"legal engine\", \"legal-engine\", \"legal_engine\", etc.\n}\n\n// infer company name from a domain (basic heuristic)\nfunction inferCompanyNameFromDomain(domain) {\n  if (!domain) return null;\n  const parts = String(domain).toLowerCase().split('.').filter(Boolean);\n\n  if (parts.length === 0) return null;\n  // drop TLD\n  parts.pop();\n\n  // drop SLD like \"co\", \"com\", \"org\", \"net\" if present at end\n  if (parts.length && ['co', 'com', 'org', 'net'].includes(parts[parts.length - 1])) {\n    parts.pop();\n  }\n\n  const candidate = parts[parts.length - 1] || null;\n  return candidate;\n}\n\nfunction unique(arr) {\n  return Array.from(new Set(arr));\n}\n\nfunction pick(...vals) {\n  return vals.find(v => v !== undefined && v !== null && v !== '') ?? null;\n}\n\n// --- main ---\nconst out = [];\n\nfor (const { json } of items) {\n  // Pull base fields through (customise as needed)\n  const base = {\n    id: pick(json.id, json.meetingId),\n    subject: pick(json.subject, json.meetingSubject),\n    start: pick(json.start, json.startISO, json.startTime),\n    end: pick(json.end, json.endISO, json.endTime),\n    timeZone: pick(json.timeZone, json.timezone),\n  };\n\n  // Source arrays (may or may not exist)\n  const inferredNamesFromPrev = Array.isArray(json.inferredCompanyNames) ? json.inferredCompanyNames : [];\n  const externalEmails = Array.isArray(json.externalAttendeeEmails) ? json.externalAttendeeEmails : [];\n\n  // Build individual names list (one per external attendee) using email domains when needed\n  const individualExternalCompanyNames = externalEmails.map(e => {\n    const domain = (String(e).split('@')[1] || '').toLowerCase();\n    const inferred = inferCompanyNameFromDomain(domain);\n    return inferred || null;\n  }).filter(Boolean);\n\n  // Merge with prior inferred names (if any) then filter + dedupe\n  const combinedNames = [\n    ...inferredNamesFromPrev.map(String),\n    ...individualExternalCompanyNames.map(String),\n  ]\n    .map(s => s.trim())\n    .filter(Boolean)\n    .filter(n => !isFilteredCompany(n));\n\n  const externalCompanyNames = unique(combinedNames);\n\n  out.push({\n    json: {\n      ...base,\n\n      // keep original lists if you want\n      externalAttendeeEmails: externalEmails,\n      inferredCompanyNamesOriginal: inferredNamesFromPrev,\n\n      // requested outputs\n      individualExternalCompanyNames,         // one per external attendee (may include duplicates)\n      externalCompanyNames,                   // unique & filtered\n      externalCompaniesAll: externalCompanyNames.join(', '), // convenience string\n\n      // pass-throughs if present\n      attendeesCount: json.attendeesCount ?? null,\n      hasExternalAttendees: json.hasExternalAttendees ?? true,\n      organizer: json.organizer ?? null,\n      location: json.location ?? null,\n      link: json.link ?? null,\n    }\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        -672
      ],
      "id": "bb9a92c9-7520-4866-8ef1-70a98fb4e55f",
      "name": "Meeting with?"
    },
    {
      "parameters": {
        "jsCode": "// Input: one item per meeting with arrays like:\n// externalAttendeeNames, externalAttendeeEmails, inferredCompanyDomains, inferredCompanyNames, subject, ...\nconst it = $input.item.json;\n\nconst names  = Array.isArray(it.externalAttendeeNames)  ? it.externalAttendeeNames  : [];\nconst emails = Array.isArray(it.externalAttendeeEmails) ? it.externalAttendeeEmails : [];\nconst domains = Array.isArray(it.inferredCompanyDomains) ? it.inferredCompanyDomains : [];\nconst companies = Array.isArray(it.inferredCompanyNames) ? it.inferredCompanyNames : [];\n\nconst out = [];\n\nfor (let i = 0; i < Math.max(names.length, emails.length); i++) {\n  const name  = names[i]  ?? '';\n  const email = emails[i] ?? '';\n  // Pick the first inferred company/domain if you don’t have a 1:1 mapping\n  const company = companies[i] ?? companies[0] ?? '';\n  const domain  = domains[i]  ?? domains[0]  ?? '';\n\n  out.push({\n    json: {\n      subject: it.subject ?? it.meetingSubject ?? '',\n      attendeeName: name,\n      attendeeEmail: email,\n      inferredCompanyName: company,\n      inferredCompanyDomain: domain,\n\n      // pass-throughs if useful\n      meetingId: it.id ?? it.meetingId ?? '',\n      start: it.start ?? it.startISO ?? '',\n      end: it.end ?? it.endISO ?? '',\n    }\n  });\n}\n\nreturn out.length ? out : [{ json: { warning: \"No external attendees to process\" } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        608,
        -1056
      ],
      "id": "b1967aa2-c2e9-4ea9-a7d2-884c7d273fbd",
      "name": "Split Into indiv Inputs"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-mini-2025-08-07",
          "mode": "list",
          "cachedResultName": "gpt-5-mini-2025-08-07"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1200,
        -528
      ],
      "id": "f8c4e05d-2f5e-4b4a-8dec-cd160e0e105a",
      "name": "OpenAI Chat Model7",
      "credentials": {
        "openAiApi": {
          "id": "LldOhLNBReShSMkE",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-mini-2025-08-07",
          "mode": "list",
          "cachedResultName": "gpt-5-mini-2025-08-07"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1776,
        -288
      ],
      "id": "6cbf8512-951a-4160-a266-c18c8119aa13",
      "name": "OpenAI Chat Model8",
      "credentials": {
        "openAiApi": {
          "id": "LldOhLNBReShSMkE",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Normalize bios from “Research Attendee (Agent)”\n// Works even if each item only has { output: \"<bio text>\" }.\n// If you also connect Input 1 with “Slim Inputs for Agent” (items with {name,email,domain}),\n// this node will align by index and/or fuzzy name to fill missing emails.\n//\n// Output (one per person):\n//   { emailLower?, email?, name?, domain?, bio, nameKey? }\n//\n// You can merge later by `emailLower` (preferred) and fall back to `nameKey` if email is missing.\n\nfunction clean(s){ return typeof s === 'string' ? s.trim() : ''; }\nfunction lower(s){ return typeof s === 'string' ? s.toLowerCase() : ''; }\n\n// --- regex helpers ---\nvar EMAIL_RE = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/ig;\nvar HOST_RE  = /\\b((?:[a-z0-9-]+\\.)+[a-z]{2,})\\b/ig;\n\n// strip ``` fences and collapse whitespace a bit\nfunction normalizeText(t){\n  var txt = String(t == null ? '' : t);\n  if (txt.indexOf('```') > -1) {\n    txt = txt.replace(/```json/ig,'').replace(/```/g,'');\n  }\n  // trim line ends, collapse >2 newlines to 2\n  txt = txt.split('\\n').map(function(l){ return l.replace(/\\s+$/,''); }).join('\\n');\n  txt = txt.replace(/\\n{3,}/g, '\\n\\n');\n  return txt.trim();\n}\n\n// naive name guess: take leading fragment before \" is \" or first line\nfunction guessNameFromBio(txt){\n  var t = clean(txt);\n  if (!t) return '';\n  var firstLine = t.split('\\n')[0];\n  var beforeIs = firstLine.toString().split(/\\s+is\\s+/i)[0];\n  var cand = clean(beforeIs.length >= 3 ? beforeIs : firstLine);\n  // Keep it reasonable: 2–5 words, title-case-ish\n  var words = cand.split(/\\s+/).filter(Boolean);\n  if (words.length > 6) words = words.slice(0,6);\n  // If it's something like \"Founder and director\", that's not a name; reject if no capital letter start\n  var hasCap = /^[A-Z]/.test(words[0] || '');\n  return hasCap ? words.join(' ') : '';\n}\n\nfunction extractEmailFromText(txt){\n  var m = String(txt||'').match(EMAIL_RE);\n  return (m && m.length) ? m[0] : '';\n}\n\nfunction extractDomainFromText(txt){\n  // pick a plausible company domain; ignore common service hosts\n  var IGNORE = { 'www.google.com':1,'linkedin.com':1,'www.linkedin.com':1,'twitter.com':1,'x.com':1,'facebook.com':1,'instagram.com':1,'youtube.com':1,'outlook.office365.com':1,'microsoft.com':1,'github.com':1,'medium.com':1 };\n  var hosts = []; var h;\n  var text = String(txt||'');\n  while ((h = HOST_RE.exec(text)) !== null){\n    var host = h[1].toLowerCase();\n    if (!IGNORE[host]) hosts.push(host);\n  }\n  // Return the most frequent non-ignored host if any\n  if (hosts.length === 0) return '';\n  var freq = {}; var best = '', bestN = -1;\n  for (var i=0;i<hosts.length;i++){ var k=hosts[i]; freq[k]=(freq[k]||0)+1; if (freq[k]>bestN){ bestN=freq[k]; best=k; } }\n  return best;\n}\n\nfunction domainFromEmail(email){\n  var e = lower(clean(email)); var at = e.indexOf('@'); return at>-1 ? e.slice(at+1) : '';\n}\n\n// --- collect inputs ---\nvar outItems = ($input.all(0) || []).map(function(i){ return i.json; });\nvar hintItems = []; try { hintItems = ($input.all(1) || []).map(function(i){ return i.json; }); } catch(_){}\n\n// Build hint maps (by index, by lower(name), by lower(email))\nvar hintsByIndex = hintItems;\nvar hintsByName  = {};\nvar hintsByEmail = {};\nfor (var hi=0; hi<hintItems.length; hi++){\n  var h = hintItems[hi] || {};\n  var hEmail = clean(h.email || (h.emailAddress && h.emailAddress.address) || '');\n  var hName  = clean(h.name || h.person || h.fullName || h.attendeeName || '');\n  if (hName) hintsByName[lower(hName)] = h;\n  if (hEmail) hintsByEmail[lower(hEmail)] = h;\n}\n\n// Process each research output\nvar results = [];\n\nfor (var i=0; i<outItems.length; i++){\n  var row = outItems[i] || {};\n  var bioRaw = (row.bio !== undefined ? row.bio : (row.output !== undefined ? row.output : (row.text !== undefined ? row.text : row.content)));\n  var bio = normalizeText(bioRaw);\n\n  // Try to resolve identity\n  var email = extractEmailFromText(bio);\n  var name  = '';\n  var domain = '';\n\n  // If no email in text, try to align with hints\n  if (!email && hintsByIndex[i]){\n    var h = hintsByIndex[i];\n    var hEmail = clean(h.email || (h.emailAddress && h.emailAddress.address) || '');\n    if (hEmail) email = hEmail;\n    name = clean(h.name || h.person || h.fullName || h.attendeeName || '');\n    domain = clean(h.domain || '');\n  }\n\n  // If still no email, try name-match from text → hintsByName\n  if (!email){\n    var guessName = guessNameFromBio(bio);\n    if (guessName && hintsByName[lower(guessName)]){\n      var hh = hintsByName[lower(guessName)];\n      email = clean(hh.email || (hh.emailAddress && hh.emailAddress.address) || '');\n      if (!name) name = clean(hh.name || hh.person || hh.fullName || hh.attendeeName || guessName);\n      if (!domain) domain = clean(hh.domain || '');\n    } else if (guessName) {\n      name = name || guessName;\n    }\n  }\n\n  // Derive domain if still missing\n  if (!domain){\n    if (email) domain = domainFromEmail(email);\n    if (!domain){\n      var dTxt = extractDomainFromText(bio);\n      if (dTxt) domain = dTxt;\n    }\n  }\n\n  // Fallback name if still empty\n  if (!name) name = guessNameFromBio(bio);\n\n  var emailLower = lower(email);\n  var nameKey = lower(clean(name));\n\n  results.push({\n    emailLower: emailLower || '',\n    email: email || '',\n    name: name || '',\n    domain: domain || '',\n    nameKey: nameKey || '',\n    bio: bio\n  });\n}\n\n// Deduplicate by emailLower if available; else by nameKey\nvar bestByKey = {};\nfor (var r=0; r<results.length; r++){\n  var it = results[r];\n  var key = it.emailLower || ('name:' + it.nameKey);\n  if (!key) continue;\n  var prev = bestByKey[key];\n  if (!prev || it.bio.length > prev.bio.length){\n    bestByKey[key] = it;\n    // prefer real email if one version had none\n    if (prev && !prev.email && it.email) bestByKey[key].email = it.email;\n    if (prev && !prev.domain && it.domain) bestByKey[key].domain = it.domain;\n  } else {\n    // keep better name if longer\n    if (it.name && (!prev.name || it.name.length > prev.name.length)) bestByKey[key].name = it.name;\n    if (it.domain && !prev.domain) bestByKey[key].domain = it.domain;\n    if (it.email && !prev.email) bestByKey[key].email = it.email;\n  }\n}\n\n// Emit items\nvar out = [];\nfor (var k in bestByKey){\n  out.push({ json: bestByKey[k] });\n}\n\nif (out.length === 0){\n  // Emit diagnostics to help wire Input 1 properly\n  return [{\n    json: {\n      warning: \"No usable bios (no email/name could be resolved). Consider connecting Slim Inputs as Input 1.\",\n      sampleKeys: Object.keys(outItems[0] || {}),\n      note: \"If Agent output only has 'output' text, merge with Slim Inputs by index so we can attach emails.\"\n    }\n  }];\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1536,
        -752
      ],
      "id": "4a03ef2d-970e-411f-9e24-8c9854855fa8",
      "name": "Normalize Summary"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2112,
        -512
      ],
      "id": "6230f8e6-b931-4efe-a601-47651878f766",
      "name": "Aggregate2"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Input examples this handles:\n * 1) A stringified JSON like \"{\\\"data\\\":[{\\\"data\\\":[{\\\"bio\\\":\\\"Ray Meiring ...\\\"}]}]}\"\n * 2) An object like { data: [ { data: [ { bio: \"...\" }, ... ] } ] }\n * 3) A Perplexity-style { biz: \"{\\\"data\\\":[{\\\"output\\\":\\\"...\\\"}]}\" } or { biz: { data:[{output:\"...\"}] } }\n * 4) A long string that contains both escaped JSON and a readable tail (fallback: strip the JSON-looking prefix)\n *\n * Output:\n * { text: \"<single clean text stream>\" }\n */\n\nfunction safeParse(x) {\n  if (x == null) return null;\n  if (typeof x === 'object') return x;\n  if (typeof x === 'string') {\n    try { return JSON.parse(x); } catch { return null; }\n  }\n  return null;\n}\n\n// Collect all \"bio\" strings recursively\nfunction collectBios(obj, out) {\n  if (!obj) return;\n  if (typeof obj === 'string') return;\n  if (Array.isArray(obj)) { obj.forEach(v => collectBios(v, out)); return; }\n  if (typeof obj === 'object') {\n    if (typeof obj.bio === 'string' && obj.bio.trim()) out.push(obj.bio.trim());\n    for (const k of Object.keys(obj)) collectBios(obj[k], out);\n  }\n}\n\n// Try to extract Perplexity-like \"output\" fields\nfunction collectOutputs(obj, out) {\n  if (!obj) return;\n  if (typeof obj === 'string') return;\n  if (Array.isArray(obj)) { obj.forEach(v => collectOutputs(v, out)); return; }\n  if (typeof obj === 'object') {\n    if (typeof obj.output === 'string' && obj.output.trim()) out.push(obj.output.trim());\n    for (const k of Object.keys(obj)) collectOutputs(obj[k], out);\n  }\n}\n\n// Fallback: remove a leading escaped-JSON prefix and keep the human-readable tail\nfunction stripEscapedJsonPrefix(s) {\n  if (typeof s !== 'string') return '';\n  // Heuristic: if it starts with \"{\\\"\" or '{\"data\":', cut everything up to the first \" - \" and keep the rest\n  if (/^\\\\?{\\\\?\"/.test(s) || s.startsWith('{\"data\"')) {\n    const idx = s.indexOf(' - ');\n    if (idx !== -1) return s.slice(idx + 3).trim();\n  }\n  // Also unescape common \\\" artifacts\n  return s.replace(/\\\\\"/g, '\"').replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t').trim();\n}\n\n// ---- main ----\nconst input = $input.item.json;\n\n// 1) Find candidate sources\n// - direct text field\nlet textRaw = input.text || input.output || input.bio || null;\n\n// - people/text payload often under textPayload (from your merge packing), or directly at root\nconst peopleObj = input.textPayload || input.peoplePayload || input;\n\n// - biz payload (could be string or object)\nlet bizObj = input.bizPayload || input.biz || null;\nbizObj = safeParse(bizObj) || bizObj; // parse if string\n\n// 2) Try to assemble text from structured objects first\nconst bios = [];\ncollectBios(peopleObj, bios);\n\nconst bizOutputs = [];\ncollectOutputs(bizObj, bizOutputs);\n\n// 3) If we didn’t get anything, try to parse the root if it’s a stringified JSON\nif (!bios.length && typeof input === 'string') {\n  const parsed = safeParse(input);\n  if (parsed) collectBios(parsed, bios);\n}\n\n// 4) Build the final text\nlet blocks = [];\n\n// prefer bios (richest text you showed)\nif (bios.length) blocks.push(bios.join('\\n\\n'));\n\n// include biz output if present\nif (bizOutputs.length) blocks.push(bizOutputs.join('\\n\\n'));\n\n// if still nothing, fall back to stripping messy string content\nif (!blocks.length) {\n  // Pick the most likely raw string field to clean\n  const candidates = [\n    textRaw,\n    typeof input === 'string' ? input : null,\n    typeof input?.peoplePayload === 'string' ? input.peoplePayload : null,\n    typeof input?.biz === 'string' ? input.biz : null\n  ].filter(Boolean);\n\n  if (candidates.length) {\n    const cleaned = stripEscapedJsonPrefix(candidates[0]);\n    if (cleaned) blocks.push(cleaned);\n  }\n}\n\n// As a last resort, emit something explicit\nif (!blocks.length) blocks.push('No readable text content found.');\n\n// Output single text stream\nreturn [{\n  json: {\n    text: blocks.join('\\n\\n---\\n\\n')\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2336,
        -976
      ],
      "id": "3d69ea74-0c93-4d92-9490-4977a0d402b8",
      "name": "Biz & Attendee Compiler"
    },
    {
      "parameters": {
        "jsCode": "// Collect all \"output\" strings from all incoming items and return ONE item with a clean text stream.\n\nfunction safeParse(x) {\n  if (x == null) return null;\n  if (typeof x === 'object') return x;\n  if (typeof x === 'string') { try { return JSON.parse(x); } catch { return null; } }\n  return null;\n}\n\nfunction collectOutputs(obj, out) {\n  if (!obj) return;\n  if (typeof obj === 'string') {\n    const parsed = safeParse(obj);\n    if (parsed) { collectOutputs(parsed, out); return; }\n    // plain string fallback\n    const s = obj.trim();\n    if (s) out.push(s);\n    return;\n  }\n  if (Array.isArray(obj)) { obj.forEach(v => collectOutputs(v, out)); return; }\n\n  // object\n  if (typeof obj.output === 'string' && obj.output.trim()) out.push(obj.output.trim());\n  if (Array.isArray(obj.data)) obj.data.forEach(v => collectOutputs(v, out));\n\n  // scan other properties just in case\n  for (const k of Object.keys(obj)) {\n    if (k === 'data' || k === 'output') continue;\n    const v = obj[k];\n    if (typeof v === 'string' || Array.isArray(v) || (v && typeof v === 'object')) {\n      collectOutputs(v, out);\n    }\n  }\n}\n\nconst items = $input.all();\nconst outputs = [];\nfor (const it of items) {\n  collectOutputs(it.json, outputs);\n}\n\n// de-dup consecutive identical blocks; keep order\nconst merged = [];\nfor (const s of outputs) {\n  if (merged.length === 0 || merged[merged.length - 1] !== s) merged.push(s);\n}\n\n// Build single text stream\nconst text = merged.join('\\n\\n---\\n\\n') || 'No output text found.';\n\nreturn [{ json: { text } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2336,
        -512
      ],
      "id": "8076883c-9e2d-48f4-8836-7cd1b3dcb1dc",
      "name": "Biz Name compiler"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2560,
        -832
      ],
      "id": "e7880d92-629c-4271-bc6f-b92a7c130b8d",
      "name": "Merge1"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2112,
        -976
      ],
      "id": "4e12b0c4-6301-465f-85f0-08a053f07268",
      "name": "Aggregate1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.externalCompanyNames[0] }}",
        "options": {
          "systemMessage": "TASK:\nAct as an expert researcher, produce the most likely name for the company that would be their trading name if listed on their corporate website, using the Perplexity Search tool to perform the following task robustly. \n\nProduce the most likely name for the company that would be their trading name if listed on their corporate website\n\nOUTPUT:\nCompany name",
          "returnIntermediateSteps": false
        }
      },
      "id": "133adf94-d3ab-439a-8a88-71bb28c4e06a",
      "name": "Research Biz Name",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        1760,
        -512
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1824,
        -976
      ],
      "id": "652f3b5b-fa6d-448f-b5a8-fd6789e023b1",
      "name": "Merge"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2784,
        -832
      ],
      "id": "d67f28d2-6292-4078-8f1d-1160b557bc09",
      "name": "Aggregate3"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "803e81bc-4a66-48b7-b461-026276603f7c",
              "name": "data",
              "value": "={{ $json.data }}",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3456,
        -592
      ],
      "id": "610dcd7e-3d9c-497b-a27f-6b9bcab5d15e",
      "name": "Set Nodes to pass"
    },
    {
      "parameters": {
        "toRecipients": "lara@legalengine.co.uk",
        "subject": "No meeting found",
        "bodyContent": "Hi, unfortunatley I did not find any meetings in your diary for the time period I looked, try setting a different timescale.\n\nBest regards,\n\nLuke\nLegal Engine AI Agent",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.microsoftOutlook",
      "typeVersion": 2,
      "position": [
        160,
        -240
      ],
      "id": "512c0278-11e6-44ec-ac79-d930080b5242",
      "name": "No meetings found",
      "webhookId": "4f380d53-4802-4b8e-974a-104d124c1478",
      "credentials": {
        "microsoftOutlookOAuth2Api": {
          "id": "I89nsEwUWKSmmCbY",
          "name": "Microsoft Outlook - Lara @ Legal Engine"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "98f9bc2a-1573-4fac-9b00-ff6b486b95aa",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -2304,
        -528
      ],
      "id": "fd5eefbb-159c-4b5e-aaf0-3b97f671ff06",
      "name": "Post meeting Webhook",
      "webhookId": "98f9bc2a-1573-4fac-9b00-ff6b486b95aa"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.attendeeName }}\n{{ $json.inferredCompanyName }}",
        "options": {
          "systemMessage": "TASK\nYou are an expert research agent. You will be give the name and company for a meeting attendee, and you will use your Perplexity tool to research about them and and produce a meeting-ready executive bio. The main aim is to allow the user to build rapport and be able to reference their background and experience in the meeting such as current and past roles, prior companies, locations they've worked in the past and their current working location.\n\nSCOPE & PRIORITIES\n- Time horizon for “recent”: last 60 months (weight these details highest).\n- Full coverage window: last 10 years (include major roles/achievements).\n- Audience: internal meeting attendees who need quick, rapport-useful context.\n\nCONSTRAINTS\n- The `bio_400_words` field must be ~400 words (±10%).\n- Use UK spelling and a professional, neutral tone.\n- Each role in `role_history` should include dates if available and a 1–2 sentence impact summary."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        832,
        -1152
      ],
      "id": "334efeff-fa52-4be0-a33d-c80d6b8689aa",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-5-mini",
          "mode": "list",
          "cachedResultName": "gpt-5-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        848,
        -928
      ],
      "id": "e0774576-21ab-4356-bd4f-575d3b8610bc",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "LldOhLNBReShSMkE",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": "sonar-pro",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "options": {
          "maxTokens": 2500,
          "temperature": 0.2
        },
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        976,
        -928
      ],
      "id": "eeb4efe7-75ca-4e6c-b966-ec0da2a727a6",
      "name": "Perplexity",
      "credentials": {
        "perplexityApi": {
          "id": "pOqM7kFIqiYB3qGU",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.subject }}.\n{{ $json.externalCompanyNames[0] }}",
        "options": {
          "systemMessage": "=TASK\nYou are an expert research agent. You will be give the name of a company whom I am meeting with representatives from, and you will use your Perplexity tool to research about them and and produce a meeting-ready executive bio. The main aim is to allow the user to have a robust knowledge relating to the work the company does, it's background, what it's best known for and any particularly noteworthy acolades. Specifically look for anything that has been published in the last month.\n\n\nSCOPE & PRIORITIES\n- Time horizon for “recent”: last 60 months (weight these details highest).\n- Full coverage window: last 20 years (include major roles/achievements).\n- Audience: meeting attendees who need quick, rapport-useful context.\n\nCONSTRAINTS\n- Summary should be approx 500 words\n- Use UK spelling and a professional, neutral tone.\n",
          "returnIntermediateSteps": false
        }
      },
      "id": "0192f3d5-181d-464b-af47-4c494b22e343",
      "name": "Research Biz",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        1184,
        -752
      ],
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Extract organiser details from a Microsoft Graph Calendar event (fast & robust).\n// Output: ONE item with organiser-prefixed fields.\n\nconst it = $input.item.json;\n\n// ---------- helpers ----------\nconst val = (s) => (typeof s === 'string' ? s.trim() : '');\nconst low = (s) => (typeof s === 'string' ? s.toLowerCase() : s);\nconst looksEmail = (s) => /@/.test(s);\n\nfunction splitName(fullName) {\n  const parts = (fullName || '').trim().split(/\\s+/).filter(Boolean);\n  if (!parts.length) return { firstName: '', lastName: '' };\n  if (parts.length === 1) return { firstName: parts[0], lastName: '' };\n  return { firstName: parts[0], lastName: parts.slice(1).join(' ') };\n}\n\nfunction inferOrgFromEmail(email) {\n  const m = (email || '').toLowerCase().match(/@([^@]+)$/);\n  if (!m) return '';\n  const firstLabel = m[1].split('.')[0]; // first DNS label\n  return firstLabel\n    .split('-')\n    .filter(Boolean)\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n}\n\n// Reads either a true array at obj[key] or flattened keys like key[0], key[1], ...\nfunction getIndexedArray(obj, baseKey) {\n  const direct = obj?.[baseKey];\n  if (Array.isArray(direct)) return direct.slice();\n\n  const arr = [];\n  for (const k of Object.keys(obj || {})) {\n    if (!k.startsWith(baseKey + '[')) continue;\n    const m = k.match(new RegExp(`^${baseKey}\\\\[(\\\\d+)\\\\]$`));\n    if (m) {\n      const idx = Number(m[1]);\n      if (!Number.isNaN(idx)) arr[idx] = obj[k];\n    }\n  }\n  return arr;\n}\n\nfunction pickFirst(arr) {\n  return Array.isArray(arr) && arr.length ? val(arr[0]) : '';\n}\n\n// ---------- pass-throughs (Graph fields first) ----------\nconst subject   = it.subject ?? it.meetingSubject ?? '';\nconst meetingId = it.id ?? it.meetingId ?? '';\nconst start     = (it.start && (it.start.dateTime || it.start)) ?? it.startISO ?? '';\nconst end       = (it.end && (it.end.dateTime || it.end)) ?? it.endISO ?? '';\nconst timeZone  = (it.start && it.start.timeZone) || it.timeZone || '';\n\n// ---------- primary: Graph organiser ----------\nlet organiserFullName = '';\nlet organiserEmail = '';\nlet organiserJobTitle = '';\nlet organiserOrganisation = '';\n\n// Graph-style organiser\nif (it.organizer && typeof it.organizer === 'object') {\n  const ea = it.organizer.emailAddress || it.organizer.email || it.organizer.mail || {};\n  if (typeof ea === 'object') {\n    organiserFullName = val(ea.name || ea.displayName || '');\n    organiserEmail    = low(val(ea.address || ea.emailAddress || ''));\n  } else if (typeof ea === 'string') {\n    if (ea.includes('@')) organiserEmail = low(val(ea));\n    else organiserFullName = val(ea);\n  }\n\n  organiserJobTitle = val(it.organizer.jobTitle || it.organizer.title || it.organizer.role || '');\n  organiserOrganisation = val(\n    it.organizer.organisation || it.organizer.organization || it.organizer.company || it.organizer.companyName || ''\n  );\n}\n\n// ---------- fallbacks from flat fields ----------\nif (!organiserFullName) {\n  organiserFullName =\n    val(it.organiserName) ||\n    val(it.organizerName) ||\n    val(it.organiserFullName) ||\n    val(it.organizerFullName) ||\n    val(it.hostName) ||\n    val(it.chairName) ||\n    '';\n}\nif (!organiserEmail) {\n  organiserEmail =\n    low(val(it.organiserEmail)) ||\n    low(val(it.organizerEmail)) ||\n    '';\n}\nif (!organiserJobTitle) {\n  organiserJobTitle =\n    val(it.organiserRole) ||\n    val(it.organizerRole) ||\n    val(it.organiserTitle) ||\n    val(it.organizerTitle) ||\n    val(it.hostTitle) ||\n    val(it.chairTitle) ||\n    '';\n}\nif (!organiserOrganisation) {\n  organiserOrganisation =\n    val(it.organiserOrganisation) ||\n    val(it.organizerOrganization) ||\n    val(it.organiserCompany) ||\n    val(it.organiserCompanyName) ||\n    pickFirst(it.inferredCompanyNames) ||\n    '';\n}\nif (!organiserOrganisation && organiserEmail) {\n  organiserOrganisation = inferOrgFromEmail(organiserEmail);\n}\n\n// ---------- secondary fallback: infer organiser from attendees (first internal) ----------\nif (!organiserEmail && !organiserFullName) {\n  // Use arrays if present (Graph also has attendees array of objects, but we’ll align with your arrays for speed)\n  const attendeeEmails  = getIndexedArray(it, 'attendeeEmails').map(e => low(val(e))).filter(Boolean);\n  const attendeeNames   = getIndexedArray(it, 'attendeeNames').map(n => val(n));\n  const externalEmails  = getIndexedArray(it, 'externalAttendeeEmails').map(e => low(val(e))).filter(Boolean);\n  const externalSet = new Set(externalEmails);\n\n  // Pick the first attendee who is NOT external\n  for (let i = 0; i < Math.max(attendeeEmails.length, attendeeNames.length); i++) {\n    const em = attendeeEmails[i] || '';\n    if (!em || externalSet.has(em)) continue;\n\n    organiserEmail = em;\n\n    const nmRaw = attendeeNames[i] || '';\n    const nm = nmRaw && !looksEmail(nmRaw) ? nmRaw : '';\n    organiserFullName = nm;\n\n    if (!organiserOrganisation) organiserOrganisation = inferOrgFromEmail(organiserEmail);\n    break;\n  }\n\n  // If still nothing, try Graph attendees array of objects\n  if (!organiserEmail && Array.isArray(it.attendees)) {\n    for (const a of it.attendees) {\n      const ea = a?.emailAddress;\n      const addr = low(val(ea?.address));\n      if (!addr) continue;\n      // If externals are known, skip them\n      if (externalEmails.length && externalSet.has(addr)) continue;\n\n      organiserEmail = addr;\n      organiserFullName = organiserFullName || val(ea?.name || ea?.displayName || '');\n      organiserOrganisation = organiserOrganisation || inferOrgFromEmail(addr);\n      break;\n    }\n  }\n}\n\n// ---------- build names ----------\nconst { firstName: organiserFirstName, lastName: organiserLastName } = splitName(organiserFullName);\n\n// ---------- validate & return ----------\nif (!organiserEmail && !organiserFullName) {\n  return [{\n    json: {\n      warning: 'No organiser found after Graph/flat/attendees checks',\n      subject, meetingId, start, end, timeZone\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    organiserFullName,\n    organiserFirstName,\n    organiserLastName,\n    organiserJobTitle,\n    organiserEmail,\n    organiserOrganisation,\n    subject,\n    meetingId,\n    start,\n    end,\n    timeZone\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        608,
        -96
      ],
      "id": "7c1f0e42-8943-47e4-8196-180d090f2315",
      "name": "Organisers Details"
    },
    {
      "parameters": {
        "jsCode": "// Input: one item per meeting with arrays like:\n// attendeeNames, attendeeEmails, externalAttendeeEmails, subject, ...\n// Output: one item per INTERNAL attendee (excluding organiser & externals)\n\nconst it = $input.item.json;\n\nconst names  = Array.isArray(it.attendeeNames)  ? it.attendeeNames  : [];\nconst emails = Array.isArray(it.attendeeEmails) ? it.attendeeEmails : [];\n\nconst externalEmails = Array.isArray(it.externalAttendeeEmails)\n  ? it.externalAttendeeEmails.map(e => (typeof e === 'string' ? e.trim().toLowerCase() : ''))\n  : [];\n\nconst organiserEmail = (it.organiserEmail || it.organizerEmail || '').toLowerCase().trim();\n\nconst out = [];\n\nconst norm = s => (typeof s === 'string' ? s.trim() : '');\nconst looksEmail = s => /@/.test(s);\n\nfunction splitName(fullName) {\n  const parts = (fullName || '').trim().split(/\\s+/).filter(Boolean);\n  if (!parts.length) return { firstName: '', lastName: '' };\n  if (parts.length === 1) return { firstName: parts[0], lastName: '' };\n  return { firstName: parts[0], lastName: parts.slice(1).join(' ') };\n}\n\nfunction orgFromEmail(email) {\n  const m = (email || '').toLowerCase().match(/@([^@]+)$/);\n  if (!m) return '';\n  const domain = m[1]; // e.g. legalengine.co.uk or simmons-simmons.con\n  const firstLabel = domain.split('.')[0]; // legalengine / simmons-simmons\n  // Title-case hyphen-separated words: \"simmons-simmons\" -> \"Simmons Simmons\"\n  return firstLabel\n    .split('-')\n    .filter(Boolean)\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n}\n\nconst externalSet = new Set(externalEmails.filter(Boolean));\nconst seen = new Set(); // dedupe by email\n\nfor (let i = 0; i < Math.max(names.length, emails.length); i++) {\n  const emailRaw = emails[i] ?? '';\n  const email = emailRaw.toLowerCase().trim();\n  if (!email) continue;\n\n  // Exclude externals & organiser\n  if (externalSet.has(email)) continue;\n  if (organiserEmail && email === organiserEmail) continue;\n\n  // Dedupe\n  if (seen.has(email)) continue;\n  seen.add(email);\n\n  // Name handling: ignore if it looks like an email\n  const nameRaw = norm(names[i] ?? '');\n  const fullName = nameRaw && !looksEmail(nameRaw) ? nameRaw : '';\n  const { firstName, lastName } = splitName(fullName);\n\n  out.push({\n    json: {\n      subject: it.subject ?? it.meetingSubject ?? '',\n      fullName,\n      firstName,\n      lastName,\n      role: '', // no role available in this input\n      email,\n      organisation: orgFromEmail(email),\n\n      // pass-throughs if useful\n      meetingId: it.id ?? it.meetingId ?? '',\n      start: it.start ?? it.startISO ?? '',\n      end: it.end ?? it.endISO ?? '',\n    }\n  });\n}\n\nreturn out.length ? out : [{ json: { warning: \"No internal attendees to process\" } }];\n"
      },
      "id": "f760525b-dd8f-4f5f-9b7c-6222d021bb30",
      "name": "Internal meeting attendees",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        608,
        -288
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "f2141cf2-1196-4521-b206-00def7b641ff",
              "leftValue": "",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "584d30c1-b990-4483-bebf-e328c5cfeec6",
      "name": "IF — No meetings Found",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -64,
        -512
      ]
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        896,
        -192
      ],
      "id": "5cf520a5-73e6-499a-a9f6-cc57b30a1324",
      "name": "Merge2"
    },
    {
      "parameters": {
        "model": "sonar-pro",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "options": {
          "maxTokens": 2500,
          "temperature": 0.2
        },
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        1328,
        -528
      ],
      "id": "5e2930c1-78af-41b3-b1d7-dd639018816d",
      "name": "Perplexity2",
      "credentials": {
        "perplexityApi": {
          "id": "pOqM7kFIqiYB3qGU",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "model": "sonar-pro",
        "messages": {
          "message": [
            {
              "content": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('message0_Text', ``, 'string') }}"
            }
          ]
        },
        "options": {
          "maxTokens": 2500,
          "temperature": 0.3
        },
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.perplexityTool",
      "typeVersion": 1,
      "position": [
        1904,
        -288
      ],
      "id": "0fafd9e2-51b7-4f76-95b3-4ed444c9449c",
      "name": "Perplexity1",
      "credentials": {
        "perplexityApi": {
          "id": "pOqM7kFIqiYB3qGU",
          "name": "Perplexity account"
        }
      }
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1248,
        -192
      ],
      "id": "bcea00c3-be32-4e88-b4a2-4548a95ee7c3",
      "name": "Aggregate4"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        3232,
        -592
      ],
      "id": "1df4f965-fea9-4a49-a71b-f99739634d16",
      "name": "Aggregate5"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3008,
        -592
      ],
      "id": "98a3dcaa-5a03-4f85-82bb-bc61a7190232",
      "name": "Merge3"
    },
    {
      "parameters": {
        "jsCode": "// --- Enhanced Function node code ---\n// Handles multiple ISO datetime fields on the same item\n// (e.g. now, Earliest_Date, etc.)\n\nconst input = $input.first().json;\n\n// Helper to zero-pad\nconst pad = n => n.toString().padStart(2, '0');\n\n// Identify fields that look like ISO dates\nconst isoDateFields = Object.keys(input).filter(key => {\n  const value = input[key];\n  return typeof value === \"string\" && /^\\d{4}-\\d{2}-\\d{2}T/.test(value);\n});\n\n// Function to format a given ISO datetime\nfunction formatDateField(label, isoString) {\n  const d = new Date(isoString);\n\n  const dd = pad(d.getDate());\n  const mm = pad(d.getMonth() + 1);\n  const yy = d.getFullYear().toString().slice(-2);\n\n  const formattedDate = `${dd}${mm}${yy}`;\n  const formattedTime = `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;\n\n  const localDate = d.toLocaleDateString(\"en-GB\");\n  const localTime = d.toLocaleTimeString(\"en-GB\", { hour12: false });\n\n  return {\n    original: isoString,\n    formattedDate,\n    formattedTime,\n    localDate,\n    localTime,\n  };\n}\n\n// Build output JSON dynamically for all detected ISO fields\nconst output = {};\n\nfor (const field of isoDateFields) {\n  output[field] = formatDateField(field, input[field]);\n}\n\nreturn [{ json: output }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1184,
        -432
      ],
      "id": "6f79c566-fde9-43df-abfc-fdd1f776de3c",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "5f981a67-fd06-4687-abcc-29295939493b",
              "name": "Task",
              "value": "=retrieve all events in my calendar",
              "type": "string"
            },
            {
              "id": "e1c34d3d-8e39-402f-a425-29cde0597d15",
              "name": "Event_Name",
              "value": "Lee<>Luke Post Meeting Check in",
              "type": "string"
            },
            {
              "id": "20392a74-7c3d-4e25-9334-7d905ad8ecb4",
              "name": "Event_Length",
              "value": "15",
              "type": "string"
            },
            {
              "id": "2c15d529-20de-4162-89ae-e154d0ee71ea",
              "name": "Invite",
              "value": "Nobody",
              "type": "string"
            },
            {
              "id": "050af3be-9bd0-4f36-95be-52fed5988834",
              "name": "Private?",
              "value": "Not Private",
              "type": "string"
            },
            {
              "id": "12577a6e-5429-4d93-a3fb-5112006411e2",
              "name": "Starting",
              "value": "on the hour, quarter past, half past or quarter to the hour",
              "type": "string"
            },
            {
              "id": "45abb33b-41be-48ca-a457-7ca6915625aa",
              "name": "Date",
              "value": "Today",
              "type": "string"
            },
            {
              "id": "3f12ef22-b095-4a74-847f-fa7a03ff9244",
              "name": "Earliest_Start",
              "value": "8am",
              "type": "string"
            },
            {
              "id": "d837939f-2d8a-4b83-a3d9-be286ab25ba3",
              "name": "Latest_Finish",
              "value": "6pm",
              "type": "string"
            },
            {
              "id": "938f4aa6-3b76-45ed-afc0-af516712ea8d",
              "name": "Alert_Mins",
              "value": "15",
              "type": "string"
            },
            {
              "id": "a6c43084-4036-42b3-b8f4-cf1d274bea8a",
              "name": "In_Last_X_Days",
              "value": "3",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -2080,
        -432
      ],
      "id": "eaceb583-3241-42f3-9107-0f4361eb93eb",
      "name": "Task"
    },
    {
      "parameters": {
        "operation": "subtractFromDate",
        "magnitude": "={{ $json.currentDate }}",
        "duration": "={{ $('Task').item.json.In_Last_X_Days }}",
        "outputFieldName": "Earliest_Date",
        "options": {}
      },
      "type": "n8n-nodes-base.dateTime",
      "typeVersion": 2,
      "position": [
        -1632,
        -432
      ],
      "id": "6b04c1b3-62e5-4960-940a-f5aef9daf905",
      "name": "Last X days"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "5f981a67-fd06-4687-abcc-29295939493b",
              "name": "now",
              "value": "={{ $('Today').item.json.currentDate }}",
              "type": "string"
            },
            {
              "id": "57dec45b-fa48-4624-96fa-3298ada3cea2",
              "name": "Earliest_Date",
              "value": "={{ $json.Earliest_Date }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1408,
        -432
      ],
      "id": "b1878ff2-cba9-42bb-b474-0f5d338884cb",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.dateTime",
      "typeVersion": 2,
      "position": [
        -1856,
        -432
      ],
      "id": "10c44522-6d7d-4c0e-9d94-72d49ef8ea14",
      "name": "Today"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        -736,
        -432
      ],
      "id": "d0521c20-f618-4dc5-9706-656ad20b16ff",
      "name": "Aggregate6"
    },
    {
      "parameters": {
        "resource": "event",
        "filters": {
          "custom": "=start/dateTime ge '{{ $json.Earliest_Date.original }}' and start/dateTime lt '{{ $('Today').item.json.currentDate }}'"
        }
      },
      "type": "n8n-nodes-base.microsoftOutlook",
      "typeVersion": 2,
      "position": [
        -960,
        -432
      ],
      "id": "81728bcf-81c7-4472-b4dd-bd34aa4d0286",
      "name": "Grab events from Andy's diary",
      "webhookId": "f2611c0a-3d2c-46c3-bd4d-9745dcddd383",
      "credentials": {
        "microsoftOutlookOAuth2Api": {
          "id": "qd4ZgBH04UILcCMZ",
          "name": "Outlook - Andy @ Legal Engine - Dec 2025"
        }
      }
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "PFod4oKlKVHNBpP4",
          "mode": "list",
          "cachedResultUrl": "/workflow/PFod4oKlKVHNBpP4",
          "cachedResultName": "DEV - A2 Taxi Luke - Post Call Luke create Agent with KB"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3680,
        -592
      ],
      "id": "21e5ad9a-89ea-4721-8355-092b76439a87",
      "name": "Call 'DEV - A2 Taxi Luke - Post Call Luke create Agent with KB'"
    },
    {
      "parameters": {
        "jsCode": "// ---------- helpers ----------\nfunction clean(s){ return typeof s === 'string' ? s.trim() : ''; }\nfunction lower(s){ return typeof s === 'string' ? s.toLowerCase() : ''; }\nfunction get(o, path, d){\n  var parts = path.split('.'); var cur = o;\n  for (var i=0;i<parts.length;i++){ \n    var k=parts[i]; \n    if (cur && typeof cur==='object' && (k in cur)) cur = cur[k]; \n    else return d; \n  }\n  return cur;\n}\nfunction domainFromEmail(email){\n  var e = lower(clean(email)); \n  var at = e.indexOf('@'); \n  return at>-1 ? e.slice(at+1) : '';\n}\nfunction normalizeIso(s){\n  s = clean(s); if (!s) return null;\n  var t = s.replace(/Z$/,''); var dot = t.indexOf('.');\n  if (dot>-1) t = t.slice(0,dot);\n  if (t.length>=19) t = t.slice(0,19); // YYYY-MM-DDTHH:MM:SS\n  return t;\n}\nfunction isoFromEpochSec(sec){\n  if (typeof sec !== 'number') return null;\n  var d = new Date(sec*1000);\n  var yyyy = d.getUTCFullYear();\n  var mm = String(d.getUTCMonth()+1).padStart(2,'0');\n  var dd = String(d.getUTCDate()).padStart(2,'0');\n  var hh = String(d.getUTCHours()).padStart(2,'0');\n  var mi = String(d.getUTCMinutes()).padStart(2,'0');\n  var ss = String(d.getUTCSeconds()).padStart(2,'0');\n  return yyyy+'-'+mm+'-'+dd+'T'+hh+':'+mi+':'+ss;\n}\nfunction startISO(ev){\n  var s1 = get(ev,'start.dateTime', null); if (s1) return normalizeIso(String(s1));\n  var s2 = ev.startISO || get(ev,'start', null); if (typeof s2 === 'string') return normalizeIso(s2);\n  var e  = (typeof ev.epoch === 'number') ? ev.epoch : get(ev,'start.epoch', null);\n  if (typeof e === 'number') return normalizeIso(isoFromEpochSec(e));\n  return null;\n}\nfunction endISO(ev){\n  var e1 = get(ev,'end.dateTime', null); if (e1) return normalizeIso(String(e1));\n  var e2 = ev.endISO || get(ev,'end', null); if (typeof e2 === 'string') return normalizeIso(e2);\n  var ee = get(ev,'end.epoch', null);\n  if (typeof ee === 'number') return normalizeIso(isoFromEpochSec(ee));\n  return null;\n}\nfunction titleCase(s){\n  return s.split(/\\s+/).filter(Boolean).map(function(w){\n    return w.charAt(0).toUpperCase() + w.slice(1);\n  }).join(' ');\n}\nfunction inferCompanyFromDomain(domain){\n  domain = lower(clean(domain || ''));\n  if (!domain) return '';\n  var IGNORE = {\n    'gmail.com':1,'googlemail.com':1,'yahoo.com':1,'hotmail.com':1,'outlook.com':1,'live.com':1,\n    'msn.com':1,'icloud.com':1,'me.com':1,'proton.me':1,'protonmail.com':1,'gmx.com':1,'aol.com':1\n  };\n  if (IGNORE[domain]) return '';\n  var d = domain.replace(/^(mail|owa|webmail|mx|smtp|imap|app|portal|m|eu|us)\\./, '');\n  var multiTLDs = ['co.uk','com.au','com.br','com.ar','com.mx','co.jp','co.in','com.sg','com.hk','com.tr','com.cn','co.nz'];\n  for (var i=0;i<multiTLDs.length;i++){\n    var tld = multiTLDs[i];\n    if (d.endsWith('.' + tld)){\n      var base = d.slice(0, -(tld.length + 1));\n      var parts = base.split('.');\n      var label = parts[parts.length - 1] || base;\n      return titleCase(label.replace(/-/g,' '));\n    }\n  }\n  var parts2 = d.split('.');\n  if (parts2.length >= 2){\n    var core = parts2[parts2.length - 2];\n    return titleCase(core.replace(/-/g,' '));\n  }\n  return titleCase(d.replace(/-/g,' '));\n}\nfunction extractJobTitles(text){\n  var t = ' ' + clean(text) + ' ';\n  if (!t) return [];\n  var pats = [\n    /\\bChief\\s+[A-Za-z&\\- ]{2,30}\\b/gi,\n    /\\b(CFO|CEO|COO|CTO|CIO|CMO|CPO|CISO|GC)\\b/gi,\n    /\\b(SVP|EVP|VP|Assoc\\.?\\s?VP|Vice\\s+President)\\b/gi,\n    /\\bManaging\\s+Director\\b/gi,\n    /\\bDirector(?:\\s+of\\s+[A-Za-z&\\- ]{2,40})?\\b/gi,\n    /\\bHead\\s+of\\s+[A-Za-z&\\- ]{2,40}\\b/gi,\n    /\\bGlobal\\s+Head\\s+of\\s+[A-Za-z&\\- ]{2,40}\\b/gi,\n    /\\bPartner\\b/gi,\n    /\\b(Associate\\s+Director|Senior\\s+Manager|Manager)\\b/gi,\n    /\\b(Consultant|Principal)\\b/gi,\n    /\\b(General\\s+Counsel|Legal\\s+Counsel|Counsel|Attorney|Solicitor|Barrister)\\b/gi,\n    /\\b(Product|Engineering|Sales|Marketing|Operations|Finance|HR|People|Data|Design)\\s+(Manager|Director|Lead|Head)\\b/gi,\n    /\\b(Account\\s+Executive|Business\\s+Development|Recruiter)\\b/gi\n  ];\n  var found = [];\n  for (var i=0;i<pats.length;i++){\n    var re = pats[i], m;\n    while ((m = re.exec(t)) !== null){\n      var val = clean(m[0]);\n      if (val && found.indexOf(val) === -1) found.push(val);\n    }\n  }\n  return found;\n}\n\n// ---------- main ----------\nvar items = $input.all().map(function(i){ return i.json || {}; });\nvar out = [];\n\nfor (var i=0;i<items.length;i++){\n  var ev = items[i] || {};\n\n  var meetingId = ev.id || ev.eventId || null;\n  var subject = clean(ev.subject || ev.Subject || '(No subject)');\n  var bodyPreview = clean(ev.description || ev.bodyPreview || '');\n  var jobTitles = extractJobTitles(bodyPreview);\n\n  var sISO = startISO(ev);\n  var eISO = endISO(ev);\n  var tz = get(ev,'start.timeZone', get(ev,'time.timeZone', get(ev,'end.timeZone','UTC')));\n\n  var attendeesRaw = Array.isArray(ev.attendees) ? ev.attendees : [];\n  var attendees = [];\n  for (var a=0; a<attendeesRaw.length; a++){\n    var att = attendeesRaw[a] || {};\n    var email = clean(att.email || get(att,'emailAddress.address',''));\n    var name  = clean(att.name || get(att,'emailAddress.name','') || (email ? email.split('@')[0] : ''));\n    var domain = domainFromEmail(email);\n    var company = inferCompanyFromDomain(domain);\n    var type = clean(att.type || '');\n    var response = clean(att.response || get(att,'status.response','') || '');\n    var respondedAt = clean(att.respondedAt || get(att,'status.time','') || '');\n\n    if (!name && !email) continue;\n\n    attendees.push({\n      name: name,\n      email: email,\n      domain: domain,\n      company: company,\n      type: type,\n      response: response,\n      respondedAt: respondedAt\n    });\n  }\n\n  attendees.sort(function(a,b){\n    var n = (a.name||'').localeCompare(b.name||''); \n    return n!==0 ? n : (a.email||'').localeCompare(b.email||'');\n  });\n\n  out.push({\n    json: {\n      meetingId: meetingId,\n      meetingSubject: subject,\n      startISO: sISO,\n      endISO: eISO,\n      timeZone: tz,\n      bodyPreview: bodyPreview,\n      jobTitles: jobTitles,\n      attendees: attendees\n    }\n  });\n}\n\n// ---- SORT MEETINGS BY DATE ----\n// Ascending (earliest → latest)\nout.sort(function(a, b) {\n  var da = new Date(a.json.startISO || 0);\n  var db = new Date(b.json.startISO || 0);\n  return da - db;\n});\n\n// For most recent first, swap to: return db - da;\n\nreturn out.length ? out : [{ json: { warning: 'No meetings found in input' } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        -928
      ],
      "id": "3c289479-f400-4a36-894f-418a4121944d",
      "name": "Clean Calendar Data1"
    },
    {
      "parameters": {
        "jsCode": "// Flatten Microsoft Graph calendar response into one item per event\n\nconst items = $input.all();\nconst output = [];\n\n// Helper. compute event length in minutes\nfunction getEventLengthMinutes(start, end) {\n  if (!start || !end) return null;\n\n  const startDate = new Date(start.dateTime || start);\n  const endDate = new Date(end.dateTime || end);\n\n  const diffMs = endDate - startDate;\n  if (isNaN(diffMs)) return null;\n\n  return Math.round(diffMs / 60000);\n}\n\n// Helper. extract Teams details from bodyPreview text\nfunction extractTeamsDetails(bodyPreview) {\n  if (!bodyPreview || typeof bodyPreview !== 'string') {\n    return {};\n  }\n\n  // Try to find a Teams join link\n  const teamsLinkMatch = bodyPreview.match(/https:\\/\\/teams\\.microsoft\\.com\\/[^\\s]+/i);\n\n  // Try to find Meeting ID and Passcode lines\n  const meetingIdMatch = bodyPreview.match(/Meeting ID:\\s*(.+)/i);\n  const passcodeMatch = bodyPreview.match(/Passcode:\\s*(.+)/i);\n\n  return {\n    teamsJoinLink: teamsLinkMatch ? teamsLinkMatch[0].trim() : null,\n    teamsMeetingId: meetingIdMatch ? meetingIdMatch[1].trim() : null,\n    teamsPasscode: passcodeMatch ? passcodeMatch[1].trim() : null,\n  };\n}\n\nfor (const item of items) {\n  const events = item.json.data || [];\n\n  for (const ev of events) {\n    const attendees = Array.isArray(ev.attendees) ? ev.attendees : [];\n\n    const attendeeNames = attendees\n      .map(a => a.emailAddress && a.emailAddress.name)\n      .filter(Boolean);\n\n    const attendeeEmails = attendees\n      .map(a => a.emailAddress && a.emailAddress.address)\n      .filter(Boolean);\n\n    const organiser = (ev.organizer && ev.organizer.emailAddress) || {};\n\n    const lengthMinutes = getEventLengthMinutes(ev.start, ev.end);\n    const teamsDetails = extractTeamsDetails(ev.bodyPreview);\n\n    output.push({\n      json: {\n        // Core fields\n        eventId: ev.id || null,\n        eventName: ev.subject || null,\n        eventLengthMinutes: lengthMinutes,\n\n        // Organiser\n        eventOrganiserName: organiser.name || null,\n        eventOrganiserEmail: organiser.address || null,\n\n        // Attendees\n        attendeeNames,\n        attendeeEmails,\n\n        // Location. fallback to null if not present\n        location: ev.location && ev.location.displayName ? ev.location.displayName : null,\n\n        // Teams details (best effort from bodyPreview)\n        teamsJoinLink: teamsDetails.teamsJoinLink || null,\n        teamsMeetingId: teamsDetails.teamsMeetingId || null,\n        teamsPasscode: teamsDetails.teamsPasscode || null,\n\n        // Extra useful metadata\n        webLink: ev.webLink || null,\n        startDateTime: ev.start && ev.start.dateTime ? ev.start.dateTime : null,\n        startTimeZone: ev.start && ev.start.timeZone ? ev.start.timeZone : null,\n        endDateTime: ev.end && ev.end.dateTime ? ev.end.dateTime : null,\n        endTimeZone: ev.end && ev.end.timeZone ? ev.end.timeZone : null,\n      }\n    });\n  }\n}\n\nreturn output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -512,
        -432
      ],
      "id": "c90b5d84-1eb8-450d-b3e5-8e0c261b9e41",
      "name": "Clean Calendar Data"
    }
  ],
  "connections": {
    "Normalize Bios": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Task",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Meetings with External Attendees": {
      "main": [
        [
          {
            "node": "Last Meeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Last Meeting": {
      "main": [
        [
          {
            "node": "Meeting with?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Split Into indiv Inputs",
            "type": "main",
            "index": 0
          },
          {
            "node": "Internal meeting attendees",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Meeting with?": {
      "main": [
        [
          {
            "node": "Research Biz Name",
            "type": "main",
            "index": 0
          },
          {
            "node": "Research Biz",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Into indiv Inputs": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model7": {
      "ai_languageModel": [
        [
          {
            "node": "Research Biz",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model8": {
      "ai_languageModel": [
        [
          {
            "node": "Research Biz Name",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Summary": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Aggregate2": {
      "main": [
        [
          {
            "node": "Biz Name compiler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Biz & Attendee Compiler": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Biz Name compiler": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Aggregate3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate1": {
      "main": [
        [
          {
            "node": "Biz & Attendee Compiler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Research Biz Name": {
      "main": [
        [
          {
            "node": "Aggregate2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Aggregate1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate3": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Nodes to pass": {
      "main": [
        [
          {
            "node": "Call 'DEV - A2 Taxi Luke - Post Call Luke create Agent with KB'",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post meeting Webhook": {
      "main": [
        [
          {
            "node": "Task",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Normalize Bios",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Perplexity": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Research Biz": {
      "main": [
        [
          {
            "node": "Normalize Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Organisers Details": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Internal meeting attendees": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — No meetings Found": {
      "main": [
        [
          {
            "node": "Extract Meetings with External Attendees",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No meetings found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Aggregate4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Perplexity2": {
      "ai_tool": [
        [
          {
            "node": "Research Biz",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Perplexity1": {
      "ai_tool": [
        [
          {
            "node": "Research Biz Name",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate4": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Aggregate5": {
      "main": [
        [
          {
            "node": "Set Nodes to pass",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "Aggregate5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Grab events from Andy's diary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Task": {
      "main": [
        [
          {
            "node": "Today",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Last X days": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Today": {
      "main": [
        [
          {
            "node": "Last X days",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate6": {
      "main": [
        [
          {
            "node": "Clean Calendar Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Grab events from Andy's diary": {
      "main": [
        [
          {
            "node": "Aggregate6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call 'DEV - A2 Taxi Luke - Post Call Luke create Agent with KB'": {
      "main": [
        []
      ]
    },
    "Clean Calendar Data": {
      "main": [
        [
          {
            "node": "Organisers Details",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF — No meetings Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "pinData": {},
  "triggerCount": 1,
  "meta": {
    "templateCredsSetupCompleted": true
  }
}